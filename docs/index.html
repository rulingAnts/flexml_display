<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FLEx XML Viewer</title>
<style>
  :root{
    --accent:#0b6edb;
    --muted:#6c6c6c;
    --bg:#fbfbfb;
    --card:#fff;
    --border:#e2e2e2;
    --highlight:#fff2b8;
  }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:18px;background:var(--bg);color:#111}
  header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  h1{font-size:1.1rem;margin:0}
  textarea{width:720px;max-width:100%;height:220px;font-family:monospace;padding:8px;border:1px solid var(--border);border-radius:6px;background:linear-gradient(#fff,#fcfcfc)}
  input[type=file]{padding:6px}
  button{background:var(--accent);color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer}
  button.secondary{background:#ddd;color:#111}
  .small-btn{padding:4px 8px;font-size:0.85rem;border-radius:6px}
  .viewer{margin-top:18px;background:var(--card);border:1px solid var(--border);padding:14px;border-radius:8px;box-shadow:0 1px 0 rgba(0,0,0,0.03)}
  /* Expand the white card to fit wide content so the browser handles scrollbars */
  .viewer{width:max-content;min-width:100%}
  /* Override XSL's table width:100% so it can define its natural width */
  .viewer .chartshell{width:max-content}
  /* Column resize UI for Text Chart tables */
  .chartshell th{position:relative}
  .col-resizer{position:absolute;top:0;right:0;width:8px;cursor:col-resize;user-select:none;height:100%}
  .col-resizer:after{content:"";position:absolute;top:0;bottom:0;left:2px;width:2px;background:transparent}
  .col-resizer.dragging:after{background:rgba(11,110,219,0.35)}
  /* Make content wrap when columns shrink (resizable mode switches table-layout to fixed) */
  .chartshell th, .chartshell td{overflow-wrap:anywhere; word-break:normal; min-width:0}
  /* Interlinear pair layout is defined by XSL-injected <style>; avoid overriding here. */
  .controls-row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:8px}
  .prologue-panel{display:none;margin-top:10px;background:#f7fbff;border:1px solid #d9ebff;padding:10px 12px;border-radius:8px}
  .prologue-grid{display:grid;grid-template-columns:140px 1fr;gap:8px 10px;align-items:center}
  .prologue-grid .full{grid-column:1 / -1}
  .prologue-grid input[type=text]{width:100%;padding:6px;border:1px solid var(--border);border-radius:6px}
  .prologue-grid select{padding:6px;border:1px solid var(--border);border-radius:6px}
  .prologue-grid textarea{width:100%;min-height:80px}
  .section-title{font-weight:600;margin:8px 0;font-size:1rem}
  ul.tree{list-style:none;margin:6px 0 6px 14px;padding-left:10px;border-left:1px dotted #ddd}
  ul.tree li{margin:4px 0;position:relative;padding-left:6px}
  .toggle{user-select:none;cursor:pointer;margin-right:6px;color:var(--accent)}
  .collapsed > ul{display:none}
  .label{font-weight:600;margin-right:6px}
  .muted{color:var(--muted);font-size:0.95rem}
  table.phonemes{width:100%;border-collapse:collapse;margin-top:8px}
  table.phonemes th, table.phonemes td{padding:8px;border-bottom:1px solid #eee;text-align:left}
  tr.highlight{background:var(--highlight) !important}
  .natclass{border:1px solid var(--border);padding:8px;border-radius:6px;margin-bottom:10px;background:linear-gradient(#fff,#f9f9f9)}
  .natclass .members{margin-top:8px;display:flex;flex-wrap:wrap;gap:8px}
  .symbol-pill{background:#f1f8ff;border:1px solid #d6eaff;padding:3px 7px;border-radius:6px;cursor:pointer}
  .symbol-pill:hover{background:#e8f2ff}
  .small-muted{font-size:0.9rem;color:var(--muted)}
  .translation-main{font-weight:600}
  .translation-others{color:var(--muted);margin-left:6px;font-size:0.95rem}
  .lang-controls{display:flex;align-items:center;gap:8px;margin:6px 0 12px 0;flex-wrap:wrap}
  .lang-controls .lang-item{display:flex;align-items:center;gap:6px;padding:4px}
  .icon-btn{background:#fff;border:1px solid #e0e0e0;padding:5px 7px;border-radius:6px;cursor:pointer}
  .wordform-card{border:1px solid #e6e6e6;padding:10px;border-radius:8px;margin-bottom:8px;background:linear-gradient(#fff,#fcfcff)}
  .wordform-header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  .wordform-main{font-weight:700;font-size:1.05rem}
  .wordform-meta{color:var(--muted);font-size:0.9rem}
  .wordform-body{margin-top:8px}
  .table-view{width:100%;border-collapse:collapse}
  .table-view th,.table-view td{padding:8px;border-bottom:1px solid #eee;text-align:left}
  .controls-inline{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  footer{margin-top:28px;padding-top:10px;border-top:1px solid #e6e6e6;color:var(--muted);font-size:0.9rem}
  /* Print-friendly adjustments */
@media print {
  /* Page margins */
  @page {
    margin: 12mm;
  }

  /* High-contrast and color handling */
  html, body {
    background: #fff !important;
    color: #000 !important;
    -webkit-print-color-adjust: exact;
    print-color-adjust: exact;
  }

  /* Slightly tighter text to fit more per page */
  :root {
    --font-size: 12px;            /* was 14px */
    --cell-border: 1px solid #000;
    --header-border-thick: 2px solid #000;
    --row-end-border: 1px solid #000;
    --para-end-border: 2px solid #000;
  }

  /* Hide interactive chrome in print */
  header, footer, .controls-row,
  #openBtn, #saveBtn, #resetBtn, #transformBtn,
  #fileInput, #xmlInput, .small-muted.controls,
  .lang-controls, .controls-inline, .viewer .small-muted {
    display: none !important;
  }

  /* Flatten the viewer card */
  .viewer {
    width: auto !important;       /* let it use full page width */
    min-width: 0 !important;
    box-shadow: none !important;
    border: none !important;
    padding: 0 !important;
    background: transparent !important;
  }

  /* Table layout for print */
  .chartshell {
    width: 100% !important;       /* fit page width */
    border-collapse: collapse !important;
    border-spacing: 0 !important;
  }

  /* Remove colored headers; rely on thicker borders */
  .row.title1 th,
  .row.title2 th {
    background: transparent !important;
  }

  /* Solid borders for cells and group rails */
  .chartshell th, .chartshell td {
    border: 1px solid #000 !important;
    padding: 6px 6px !important; /* a bit tighter for paper */
  }
  .chartshell th.group-end, .chartshell td.group-end {
    border-right: 2px solid #000 !important;
  }
  /* Preserve thicker sentence/paragraph end borders in print */
  .chartshell tr.endSent > th, .chartshell tr.endSent > td {
    border-bottom: var(--row-end-border) !important;
  }
  .chartshell tr.endPara > th, .chartshell tr.endPara > td {
    border-bottom: var(--para-end-border) !important;
  }
  .chartshell tr > .group-start:first-child {
    border-left: 2px solid #000 !important;
  }

  /* Keep rows together if possible (browser support varies) */
  .chartshell tr {
    page-break-inside: avoid;
    break-inside: avoid;
  }

  /* Interlinear: keep gloss readable in grayscale */
  .interlinear .g {
    color: #333 !important;
  }

  /* Optional: show link targets in print */
  a[href]:after {
    content: " (" attr(href) ")";
    font-size: 0.9em;
  }
}
</style>
</head>
<body>

<header>
  <h1>FLEx XML Viewer</h1>
  <div style="margin-left:auto" class="small-muted">¬© 2025 Seth Johnston</div>
</header>

  <section style="background:#eef5ff;border:1px solid #c8dbff;padding:10px 14px;border-radius:8px;margin-bottom:12px">
  <h2 style="font-size:1rem;margin-top:0">About FLEx XML Viewer</h2>
  <p>
    <strong>FLEx XML Viewer</strong> is a client-side web app for viewing and exploring
    <a href="https://software.sil.org/fieldworks/" target="_blank" rel="noopener noreferrer">FieldWorks (FLEx)</a>
    XML exports in a structured, readable format. It runs entirely in your browser and requires no server. This app is a part of the <a href="https://github.com/rulingAnts/flet" target="_blank" rel="noopener noreferrer">Field Linguistics Extension Tools collection</a>.
  </p>
  <p>This viewer supports the following FieldWorks export types:</p>
  <ul style="margin-top:4px">
    <li><strong>Lists</strong> ‚Äî displays hierarchical <code>&lt;list&gt;</code> structures as collapsible nested lists.</li>
    <li><strong>Translated Lists</strong> ‚Äî handles multilingual <code>&lt;AUni&gt;</code>-based lists with language ordering and visibility controls.</li>
    <li><strong>Phonology</strong> ‚Äî renders natural classes, phoneme inventories, and cross-references in human-readable tables.</li>
    <li><strong>Wordforms</strong> ‚Äî displays lexical items and analyses in expandable cards or sortable tables.</li>
    <li><strong>Generic XML</strong> ‚Äî provides a recursive tree view for any other well-formed XML data.</li>
  </ul>
  <p>
    This app does <em>not</em> process <strong>LIFT</strong> or <strong>FLExText</strong> exports ‚Äî those should be opened directly in FLEx. XLingPaper XML exports can open with XLingPpaer. And Word XML files should be opened in Microsoft Word.
  </p>
</section>

<textarea id="xmlInput" placeholder="Paste XML here or choose a file..."></textarea>

<div class="controls-row">
  <button id="transformBtn">Transform</button>
  <button id="resetBtn" class="secondary">Reset</button>

  <label style="display:flex;align-items:center;gap:8px" class="small-muted">
    <input id="showNames" type="checkbox"> Show element names
  </label>

  <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
    <input id="fileInput" type="file" accept=".xml,.xml.txt" />
    <button id="openBtn" class="secondary">Open in new window</button>
    <button id="saveBtn" class="secondary">Save as HTML</button>
  </div>
</div>

<!-- Optional heading and preface (HTML) to insert before a Text Chart -->
<div id="prologuePanel" class="prologue-panel" aria-live="polite">
  <div class="small-muted" style="margin-bottom:8px;font-weight:600">Chart header and note (optional)</div>
  <div class="prologue-grid">
    <label for="titleTag">Title element</label>
    <div style="display:flex;gap:8px;align-items:center">
      <select id="titleTag" aria-label="Title element">
        <option value="h1">h1</option>
        <option value="h2">h2</option>
        <option value="h3">h3</option>
        <option value="div">div</option>
        <option value="p">p</option>
      </select>
      <input id="titleText" type="text" placeholder="Enter a chart title (optional)" />
      <button id="clearTitleBtn" class="small-btn secondary" title="Clear title">Clear</button>
    </div>

    <label for="prefaceHtml">Preface (HTML allowed)</label>
    <div class="full">
      <textarea id="prefaceHtml" placeholder="Type any HTML to appear before the chart (optional)"></textarea>
      <div class="small-muted" style="margin-top:6px">
        Tip: You can include basic HTML like <code>&lt;p&gt;</code>, <code>&lt;div&gt;</code>, <code>&lt;em&gt;</code>, or links. 
        If you don't know HTML, leave that to us ‚Äî when ‚ÄúAuto-convert line breaks‚Äù is on, Enter makes a new paragraph and Shift+Enter inserts a line break.
      </div>
      <label class="small-muted" style="display:flex;align-items:center;gap:8px;margin-top:6px">
        <input id="prefaceAuto" type="checkbox" checked> Auto-convert line breaks (Enter = new paragraph, Shift+Enter = line break)
      </label>
    </div>
    <div></div>
    <div style="display:flex;gap:8px">
      <button id="clearPrefaceBtn" class="small-btn secondary" title="Clear preface">Clear preface</button>
    </div>
  </div>
</div>

<div id="viewer" class="viewer" aria-live="polite">
  <div id="renderArea" class="small-muted">Paste or upload an XML file, then click Transform.</div>
</div>

<footer>
  <div>¬© 2025 Seth Johnston. This software is licensed under the <a href="https://www.gnu.org/licenses/agpl-3.0.html" target="_blank" rel="noopener noreferrer">GNU Affero General Public License v3.0 (AGPL-3.0)</a>.</div>
  <div>The vast majority of this code was generated collaboratively with <strong>ChatGPT (GPT-5)</strong> by OpenAI, under the author‚Äôs direction and guidance.</div>
  <div>Download the latest Windows Installer from the GitHub Project page <a href="https://github.com/rulingAnts/flexml_display/" target="_blank" rel="noopener noreferrer">here</a>.</div>
</footer>

<script>
/* ===== Helpers ===== */
const byId = id => document.getElementById(id);
const escapeHtml = s => String(s||'').replace(/[&<>"]/g, c=>'&' + ({'&':'amp','<':'lt','>':'gt','"':'quot'})[c] + ';');
function create(tag, attrs={}, text){
  const el = document.createElement(tag);
  for(const k in attrs){
    if(k==='cls') el.className = attrs[k];
    else el.setAttribute(k, attrs[k]);
  }
  if(text !== undefined && text !== null) el.textContent = text;
  return el;
}

/* ===== Persistence keys and state ===== */
const LANG_PREFS_KEY = 'flex_xml_viewer_lang_prefs_v1';
const WORDFORM_PREFS_KEY = 'flex_xml_viewer_wordform_prefs_v1';
const TEXTCHART_PROLOGUE_KEY = 'flex_textchart_prologue_v1';

let globalState = {
  phonemeIndex: {},
  idToNatclassIds: {},
  natclassElements: {},
  phonemeRowIds: {},
  showNames: false
};

function saveJSON(key, obj){ try{ localStorage.setItem(key, JSON.stringify(obj)); } catch(e){} }
function loadJSON(key){ try{ const s = localStorage.getItem(key); return s ? JSON.parse(s) : null; } catch(e){ return null; } }

/* ===== File & UI wiring ===== */
byId('fileInput').addEventListener('change', async e=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const text = await f.text();
  byId('xmlInput').value = text;
});

byId('resetBtn').addEventListener('click', ()=>{
  byId('xmlInput').value = '';
  byId('renderArea').innerHTML = '<div class="small-muted">Paste or upload an XML file, then click Transform.</div>';
  // Hide optional chart prologue controls when no chart is displayed
  showProloguePanel(false);
});

byId('transformBtn').addEventListener('click', async ()=> {
  const xmlText = byId('xmlInput').value.trim();
  if(!xmlText){ alert('Please paste or upload an XML document first.'); return; }
  try {
    const p = new DOMParser();
    const xmlDoc = p.parseFromString(xmlText, 'application/xml');
    if(xmlDoc.querySelector('parsererror')) throw new Error('XML parse error');
    await renderDocument(xmlDoc);
  } catch(err){
    alert('Error parsing XML: ' + err.message);
  }
});

byId('openBtn').addEventListener('click', ()=>{
  const html = buildStandaloneHTML();
  const w = window.open('', '_blank');
  w.document.write(html);
  w.document.close();
});

function sanitizeFilename(name){
  // Remove illegal characters for Windows/macOS, collapse spaces, and trim
  return (name || 'export')
    .replace(/[\\/:*?"<>|]+/g, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .slice(0, 120);
}
function getExportTitleFromPrologue(){
  let exportTitle = 'FLEx XML View Export';
  const render = byId('renderArea');
  if(!render) return exportTitle;
  const prologueNode = render.querySelector(':scope > .chart-prologue');
  if (prologueNode) {
    const h1 = prologueNode.querySelector('h1');
    const anyHead = prologueNode.querySelector('h1,h2,h3,h4,h5,h6,div,p');
    const titleNode = h1 || anyHead;
    if (titleNode && titleNode.textContent) {
      const t = titleNode.textContent.replace(/\s+/g, ' ').trim();
      if (t) exportTitle = t;
    }
  }
  return exportTitle;
}
function suggestExportFilename(){
  const baseTitle = getExportTitleFromPrologue();
  const hasChart = !!byId('renderArea')?.querySelector('table.chartshell');
  const withContext = hasChart ? `${baseTitle} ‚Äî Text Chart` : baseTitle;
  let name = sanitizeFilename(withContext || 'FLEx XML View Export');
  if(!/\.html?$/i.test(name)) name += '.html';
  return name;
}
byId('saveBtn').addEventListener('click', async ()=>{
  const html = buildStandaloneHTML();
  const filename = suggestExportFilename();
  // Use File System Access API if available (Chrome/Edge/Electron Chromium)
  if(window.showSaveFilePicker){
    try{
      const handle = await window.showSaveFilePicker({
        suggestedName: filename,
        types: [{ description: 'HTML Document', accept: { 'text/html': ['.html', '.htm'] } }]
      });
      const writable = await handle.createWritable();
      await writable.write(new Blob([html], {type:'text/html'}));
      await writable.close();
      return;
    } catch(err){
      if(err && err.name === 'AbortError') return; // user canceled
      console.warn('showSaveFilePicker failed, falling back to download:', err);
      // fall through to anchor download
    }
  }
  // Fallback: classic download
  const blob = new Blob([html], {type:'text/html'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
});

byId('showNames').addEventListener('change', e=>{
  globalState.showNames = e.target.checked;
  document.querySelectorAll('[data-gen-label]').forEach(el=>{
    const label = el.getAttribute('data-gen-label');
    const prev = el.previousSibling;
    if(prev) prev.textContent = globalState.showNames ? (label + ': ') : '';
  });
});

/* ===== Prologue (title + preface HTML) controls wiring ===== */
function loadProloguePrefs(){
  const d = loadJSON(TEXTCHART_PROLOGUE_KEY) || {};
  return {
    tag: d.tag || 'h1',
    titleText: d.titleText || '',
    prefaceHtml: d.prefaceHtml || '', // stores raw user text or HTML
    autoConvert: typeof d.autoConvert === 'boolean' ? d.autoConvert : true
  };
}
function saveProloguePrefs(p){ saveJSON(TEXTCHART_PROLOGUE_KEY, p); }
function initPrologueControls(){
  const panel = byId('prologuePanel');
  const tagSel = byId('titleTag');
  const titleIn = byId('titleText');
  const preTA = byId('prefaceHtml');
  const preAuto = byId('prefaceAuto');
  const clearTitleBtn = byId('clearTitleBtn');
  const clearPrefaceBtn = byId('clearPrefaceBtn');
  if(!panel || !tagSel || !titleIn || !preTA) return;
  const prefs = loadProloguePrefs();
  tagSel.value = prefs.tag || 'h1';
  titleIn.value = prefs.titleText || '';
  preTA.value = prefs.prefaceHtml || '';
  if(preAuto) preAuto.checked = !!prefs.autoConvert;
  const onChange = ()=>{
    const p = { tag: tagSel.value, titleText: titleIn.value, prefaceHtml: preTA.value, autoConvert: !!(preAuto && preAuto.checked) };
    saveProloguePrefs(p);
    // Live-update DOM if a text chart is displayed
    applyPrologueToRenderArea(p);
  };
  tagSel.addEventListener('change', onChange);
  titleIn.addEventListener('input', onChange);
  preTA.addEventListener('input', onChange);
  preAuto?.addEventListener('change', onChange);
  clearTitleBtn?.addEventListener('click', ()=>{ titleIn.value=''; onChange(); });
  clearPrefaceBtn?.addEventListener('click', ()=>{ preTA.value=''; onChange(); });

  // Map Enter to paragraph and Shift+Enter to single line break within the textarea
  preTA.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){
      e.preventDefault();
      const isShift = e.shiftKey;
      const val = preTA.value;
      const start = preTA.selectionStart;
      const end = preTA.selectionEnd;
      const insertText = isShift ? '\n' : '\n\n';
      preTA.value = val.slice(0, start) + insertText + val.slice(end);
      const newPos = start + insertText.length;
      preTA.selectionStart = preTA.selectionEnd = newPos;
      onChange();
    }
  });
}
// Ensure controls are initialized on load
initPrologueControls();
function showProloguePanel(show){ byId('prologuePanel').style.display = show ? 'block' : 'none'; }
function applyPrologueToRenderArea(prefs){
  const area = byId('renderArea');
  if(!area) return;
  // Ensure a fixed container exists as the first child for prologue content
  let prologue = area.querySelector(':scope > .chart-prologue');
  if(!prologue){
    prologue = document.createElement('div');
    prologue.className = 'chart-prologue';
    area.insertBefore(prologue, area.firstChild || null);
  }
  prologue.innerHTML = '';
  const { tag, titleText } = (prefs || loadProloguePrefs());
  let { prefaceHtml, autoConvert } = (prefs || loadProloguePrefs());
  if(titleText && tag){
    const t = document.createElement(tag);
    t.textContent = titleText;
    prologue.appendChild(t);
  }
  if(prefaceHtml && prefaceHtml.trim()){
    // Convert plain text to HTML when auto-convert is on and content appears to be plain text.
    const appearsHtml = /<\s*[a-zA-Z!/]/.test(prefaceHtml);
    let htmlOut = prefaceHtml;
    if(autoConvert && !appearsHtml){
      // Treat double newlines as paragraph breaks, single newline as <br /> within a paragraph
      const norm = prefaceHtml.replace(/\r\n?/g, '\n');
      const paras = norm.split(/\n{2,}/).map(s => s.trim()).filter(Boolean);
      htmlOut = paras.map(p => `<p>${escapeHtml(p).replace(/\n/g, '<br />')}</p>`).join('\n');
    }
    const wrapper = document.createElement('div');
    wrapper.innerHTML = htmlOut;
    Array.from(wrapper.childNodes).forEach(n => prologue.appendChild(n));
  }
  // If both are empty, remove the container to avoid extra spacing
  if(!prologue.childNodes.length){ prologue.remove(); }
}

/* ===== Main detection & dispatch ===== */
async function renderDocument(xmlDoc){
  // reset state
  globalState = { phonemeIndex:{}, idToNatclassIds:{}, natclassElements:{}, phonemeRowIds:{}, showNames: byId('showNames').checked };

  const root = xmlDoc.documentElement;
  const tag = root.nodeName.toLowerCase();
  const area = byId('renderArea');
  area.innerHTML = '';

  // Detect Text Chart (Discourse chart) and render via XSLT
  if(isTextChartDocument(xmlDoc)){
    const rendered = await renderTextChart(xmlDoc);
    area.innerHTML = '';
    // Show prologue controls and inject current prologue before the chart
    showProloguePanel(true);
    applyPrologueToRenderArea(loadProloguePrefs());
    if(rendered){
      area.appendChild(rendered);
      // Enable column resizing on the text chart table
      enableTextChartColumnResize(area);
    }
    else { area.textContent = 'Failed to render Text Chart.'; }
    return;
  }

  // Order of detection: Phonology, Translated Lists (AUni multi), Monolingual list, Wordforms, Generic
  if(tag === 'phonology'){
    showProloguePanel(false);
    area.appendChild(renderPhonologyView(xmlDoc));
    return;
  }

  if(tag === 'list' || tag === 'lists'){
    // detect AUni-based multilingual lists
    const aunis = xmlDoc.querySelectorAll('AUni[ws]');
    const langSet = new Set(Array.from(aunis).map(a => a.getAttribute('ws')));
    if(langSet.size > 1){
      showProloguePanel(false);
      area.appendChild(renderTranslatedListView(root, Array.from(langSet)));
      return;
    } else {
      showProloguePanel(false);
      area.appendChild(renderListView(root));
      return;
    }
  }

  // Wordforms detection (FieldWorks uses a <wordforms> root or similar)
  const wfNodes = xmlDoc.getElementsByTagName('wordforms');
  if(wfNodes && wfNodes.length > 0){
    showProloguePanel(false);
    area.appendChild(renderWordformsView(xmlDoc));
    return;
  }

  // fallback generic
  showProloguePanel(false);
  area.appendChild(renderGenericView(root));
}

/* ===== Text Chart detection and rendering (XSLT) ===== */
function isTextChartDocument(xmlDoc){
  if(!xmlDoc || !xmlDoc.documentElement) return false;
  // Typical structure: <document><chart>...</chart></document> or a top-level <chart>
  return !!(xmlDoc.querySelector('document > chart > row') || xmlDoc.querySelector('chart > row'));
}

async function loadTextChartXSL(){
  const url = `textchart/textchart-to-html.xsl?v=${Date.now()}`;
  const resp = await fetch(url);
  if(!resp.ok) throw new Error(`Failed to fetch XSL (${resp.status})`);
  const txt = await resp.text();
  const doc = new DOMParser().parseFromString(txt, 'text/xml');
  const err = doc.getElementsByTagName('parsererror')[0];
  if(err) throw new Error('XSL parse error: ' + err.textContent.trim());
  return doc;
}

async function renderTextChart(xmlDoc){
  if(typeof XSLTProcessor === 'undefined'){
    const frag = document.createDocumentFragment();
    frag.appendChild(create('div', {cls:'small-muted'}, 'XSLTProcessor not supported in this browser.'));
    return frag;
  }
  const xslDoc = await loadTextChartXSL();
  const proc = new XSLTProcessor();
  proc.importStylesheet(xslDoc);
  try{
    // Optional: pass through debug param from URL (?debug=1)
    const urlParams = new URLSearchParams(window.location.search);
    const dbg = urlParams.get('debug');
    if(dbg && ['1','true','yes','on'].includes(dbg.toLowerCase())){
      proc.setParameter(null, 'debug', 'true');
    }
  }catch(_){/* no-op if params unsupported */}

  // Run transform to a fragment, then extract the body contents if present
  const frag = proc.transformToFragment(xmlDoc, document);
  const wrapper = document.createElement('div');
  wrapper.appendChild(frag);
  // If XSL produced a <head>, merge its styles into the page once
  const head = wrapper.querySelector('head');
  if (head) {
    // Inline <style>
    const styleEl = head.querySelector('style');
    if (styleEl) {
      const EXISTING_ID = 'textchart-xsl-style';
      let dest = document.getElementById(EXISTING_ID);
      if (!dest) {
        dest = document.createElement('style');
        dest.id = EXISTING_ID;
        document.head.appendChild(dest);
      }
      dest.textContent = styleEl.textContent || '';
    }
    // Linked stylesheets (if any in future)
    head.querySelectorAll('link[rel="stylesheet"][href]').forEach(link => {
      const href = link.getAttribute('href');
      if (!href) return;
      // Avoid duplicates by href
      const exists = Array.from(document.head.querySelectorAll('link[rel="stylesheet"][href]'))
        .some(l => l.getAttribute('href') === href);
      if (!exists) {
        const copy = document.createElement('link');
        copy.rel = 'stylesheet';
        copy.href = href;
        document.head.appendChild(copy);
      }
    });
  }
  const body = wrapper.querySelector('body');
  const outFrag = document.createDocumentFragment();
  const source = body || wrapper; // prefer body if the XSL produced a full HTML doc
  Array.from(source.childNodes).forEach(n => outFrag.appendChild(n));
  return outFrag;
}

/* ===== Monolingual List (unchanged behavior) ===== */
function renderListView(root) {
  // Accept either a single <list> or a top-level <lists> container
  if(!root) return create('div', {}, '(no list)');
  const nodeName = (root.nodeName || '').toLowerCase();
  if(nodeName === 'lists'){
    const outer = create('div');
    const lists = Array.from(root.querySelectorAll(':scope > list'));
    if(lists.length === 0) return outer;
    lists.forEach(l => outer.appendChild(renderListView(l)));
    return outer;
  }

  const container = create('div');
  // title: prefer Name or name inside the list; also accept a <name><str> pattern
  const title = (root.querySelector(':scope > name, :scope > Name')?.textContent?.trim()) || (root.querySelector(':scope > Name str, :scope > name str')?.textContent?.trim()) || 'List';
  container.appendChild(create('div', { cls: 'section-title' }, title));

  // helper to find direct "item-like" children (item, letitem, sditem)
  function itemChildrenOf(el){
    return Array.from(el.querySelectorAll(':scope > item, :scope > letitem, :scope > sditem'));
  }

  function buildItem(node) {
    const li = create('li');

    // collect children from direct item-like children and <subitems>
    const direct = itemChildrenOf(node);
    const subitemsContainer = node.querySelector(':scope > subitems');
    const sub = subitemsContainer ? itemChildrenOf(subitemsContainer) : [];
    const allChildren = direct.concat(sub);
    const hasChildren = allChildren.length > 0;

    // add toggle affordance (always present for consistent layout)
    const toggle = create('span', { cls: 'toggle' }, hasChildren ? '\u25be' : ' ');
    if(hasChildren) toggle.style.cursor = 'pointer';
    li.appendChild(toggle);

    // display name (handle <name ws="..."> and <name><str ws=...> patterns)
    const nameNode = node.querySelector(':scope > name, :scope > Name');
    const rawName = nameNode ? nameNode.textContent.trim() : (node.getAttribute && node.getAttribute('name')) || node.nodeName;
    const abbrNode = node.querySelector(':scope > abbr, :scope > Abbreviation');
    const abbrText = abbrNode ? abbrNode.textContent.trim() : (node.getAttribute && (node.getAttribute('abbr') || node.getAttribute('ws'))) || '';
    const text = abbrText ? `${rawName} (${abbrText})` : rawName;
    li.appendChild(document.createTextNode(text));

    if (hasChildren) {
      const ul = create('ul', { cls: 'tree' });
      allChildren.forEach(ci => ul.appendChild(buildItem(ci)));
      li.appendChild(ul);

      toggle.addEventListener('click', () => {
        li.classList.toggle('collapsed');
        toggle.textContent = toggle.textContent === '\u25be' ? '\u25b8' : '\u25be';
      });
    }

    return li;
  }

  // find top-level items: could be directly under list (item/letitem/sditem) or inside an <items> wrapper
  let topItems = itemChildrenOf(root);
  if(topItems.length === 0){
    const itemsWrapper = root.querySelector(':scope > items');
    if(itemsWrapper) topItems = itemChildrenOf(itemsWrapper);
  }

  const topUL = create('ul', { cls: 'tree' });
  topItems.forEach(it => topUL.appendChild(buildItem(it)));
  container.appendChild(topUL);

  return container;
}

/* ===== Translated (multilingual) List view + Language Controls ===== */
function renderTranslatedListView(root, langList){
  // canonicalize languages (stable order): prefer 'en' if present
  const langs = Array.from(langList);
  langs.sort((a,b)=>{
    if(a.toLowerCase().includes('en') && !b.toLowerCase().includes('en')) return -1;
    if(b.toLowerCase().includes('en') && !a.toLowerCase().includes('en')) return 1;
    return a.localeCompare(b);
  });

  // load saved prefs and merge defaults
  const saved = loadJSON(LANG_PREFS_KEY) || {};
  const prefs = {};
  langs.forEach((ws,i)=> {
    prefs[ws] = {
      ws,
      order: (saved[ws] && typeof saved[ws].order === 'number') ? saved[ws].order : i,
      visible: (saved[ws] && typeof saved[ws].visible === 'boolean') ? saved[ws].visible : true
    };
  });
  // compact orders
  const orderedLangs = Object.values(prefs).sort((a,b)=>a.order-b.order).map(l=>l.ws);
  orderedLangs.forEach((ws,i)=> prefs[ws].order = i);
  saveJSON(LANG_PREFS_KEY, prefs);

  const container = create('div');
  const title = root.querySelector(':scope > Name AUni[ws="en"], :scope > Name AUni, :scope > Name, :scope > name')?.textContent?.trim() || 'Translated List';
  container.appendChild(create('div', {cls:'section-title'}, title));

  const controls = create('div', {cls:'lang-controls'});
  container.appendChild(controls);

  function buildLangControls(){
    controls.innerHTML = '';
    const arr = Object.values(prefs).sort((a,b)=>a.order-b.order);
    arr.forEach((L, idx)=>{
      const item = create('div', {cls:'lang-item'});
      item.style.display = 'flex'; item.style.alignItems = 'center'; item.style.gap = '6px';

      const codeSpan = create('span', {}, L.ws);
      codeSpan.style.fontWeight = '600';
      item.appendChild(codeSpan);

      const up = create('button', {cls:'icon-btn', title:'Move up (higher priority)'}, '‚¨ÜÔ∏è');
      up.addEventListener('click', ()=> { swapOrder(L.ws, -1); });
      item.appendChild(up);

      const down = create('button', {cls:'icon-btn', title:'Move down (lower priority)'}, '‚¨áÔ∏è');
      down.addEventListener('click', ()=> { swapOrder(L.ws, +1); });
      item.appendChild(down);

      const vis = create('button', {cls:'icon-btn', title: L.visible ? 'Hide language' : 'Show language'}, L.visible ? 'üëÅÔ∏è' : 'üö´');
      vis.addEventListener('click', ()=> { prefs[L.ws].visible = !prefs[L.ws].visible; saveJSON(LANG_PREFS_KEY, prefs); buildLangControls(); renderItems(); });
      item.appendChild(vis);

      controls.appendChild(item);
    });

    const reset = create('button', {cls:'small-btn secondary', title:'Reset language order and visibility to defaults'}, 'Reset');
    reset.addEventListener('click', ()=> {
      langs.forEach((ws,i)=> { prefs[ws].order = i; prefs[ws].visible = true; });
      saveJSON(LANG_PREFS_KEY, prefs); buildLangControls(); renderItems();
    });
    controls.appendChild(reset);
  }

  const listContainer = create('div');
  container.appendChild(listContainer);

  function renderItems(){
    listContainer.innerHTML = '';
    const ordered = Object.values(prefs).sort((a,b)=>a.order-b.order).filter(l=>l.visible).map(l=>l.ws);
    if(ordered.length === 0){
      listContainer.appendChild(create('div', {cls:'small-muted'}, 'No languages selected. Use controls to show at least one language.'));
      return;
    }
    const poss = root.querySelector(':scope > Possibilities, :scope > possibilities') || root;
    const topItems = Array.from(poss.children).filter(c=>c.nodeType === 1);
    const topUL = create('ul', {cls:'tree'});
    topItems.forEach(ti => topUL.appendChild(buildItem(ti, ordered)));
    listContainer.appendChild(topUL);
  }

  function buildItem(node, visibleLangs){
    const li = create('li');
    const sub = node.querySelector(':scope > SubPossibilities, :scope > SubPossibility, :scope > Possibilities');
    const hasSub = sub && Array.from(sub.children).some(c=>c.nodeType === 1);
    const toggle = create('span', {cls:'toggle'}, hasSub ? '‚ñæ' : ' ');
    if(hasSub) toggle.style.cursor = 'pointer';
    li.appendChild(toggle);

    const nameNode = node.querySelector(':scope > Name, :scope > name');
    const abbrNode = node.querySelector(':scope > Abbreviation, :scope > abbr');
    const names = collectAUniMap(nameNode);
    const abbrs = collectAUniMap(abbrNode);
    const inline = create('span');
    inline.innerHTML = buildMultilingualInlineHTML(names, abbrs, visibleLangs);
    li.appendChild(inline);

    if(hasSub){
      const ul = create('ul', {cls:'tree'});
      Array.from(sub.children).filter(c=>c.nodeType===1).forEach(ch => ul.appendChild(buildItem(ch, visibleLangs)));
      li.appendChild(ul);
      toggle.addEventListener('click', ()=> {
        li.classList.toggle('collapsed');
        toggle.textContent = toggle.textContent === '‚ñæ' ? '‚ñ∏' : '‚ñæ';
      });
    }
    return li;
  }

  function swapOrder(ws, delta){
    const entries = Object.values(prefs).sort((a,b)=>a.order-b.order);
    const idx = entries.findIndex(e => e.ws === ws);
    const target = idx + delta;
    if(target < 0 || target >= entries.length) return;
    const a = entries[idx], b = entries[target];
    const t = a.order; a.order = b.order; b.order = t;
    saveJSON(LANG_PREFS_KEY, prefs); buildLangControls(); renderItems();
  }

  buildLangControls();
  renderItems();
  return container;
}

/* ===== Helpers for multilingual lists ===== */
function collectAUniMap(node){
  if(!node) return [];
  const a = Array.from(node.querySelectorAll('AUni'));
  if(a.length) return a.map(x => ({ ws: x.getAttribute('ws') || '', text: x.textContent.trim() }));
  // fallback: Name with ws attribute (mono) or plain text
  if(node.hasAttribute && node.hasAttribute('ws')) return [{ ws: node.getAttribute('ws') || '', text: (node.textContent || '').trim() }];
  const txt = (node.textContent || '').trim();
  return txt ? [{ ws:'', text: txt }] : [];
}

function buildMultilingualInlineHTML(names, abbrs, visibleLangs){
  if(!names || names.length === 0) return '(unnamed)';
  const shown = visibleLangs.map(ws => names.find(n => n.ws === ws)).filter(Boolean);
  if(!shown.length) return '(none)';
  const main = shown[0];
  const others = shown.slice(1);
  let html = `<span class="translation-main">${escapeHtml(main.text)}</span>`;
  if(others.length) html += ' ' + others.map(o => `<span class="translation-others">${escapeHtml(o.text)}</span>`).join(' ¬∑ ');
  if(abbrs && abbrs.length){
    const abv = visibleLangs.map(ws => (abbrs.find(a => a.ws === ws) || {}).text).filter(Boolean);
    if(abv.length) html += ` <span class="small-muted">[${abv.map(escapeHtml).join(' / ')}]</span>`;
  }
  return html;
}

/* ===== Generic recursive fallback (unchanged) ===== */
function renderGenericView(root){
  const container = create('div');
  container.appendChild(create('div', {cls:'section-title'}, 'Generic XML View'));
  const rootUL = create('ul', {cls:'tree'});
  rootUL.appendChild(build(root));
  container.appendChild(rootUL);
  return container;

  function build(node){
    const li = create('li');
    const childElements = Array.from(node.childNodes).filter(n => n.nodeType === 1 || (n.nodeType === 3 && n.nodeValue.trim()));
    const hasChildren = childElements.length > 0;
    const toggle = create('span', {cls:'toggle'}, hasChildren ? '‚ñæ' : ' ');
    if(hasChildren) toggle.style.cursor='pointer';
    li.appendChild(toggle);

    const labelText = node.nodeType === 1 ? node.nodeName : '';
    const labelSpan = create('span');
    if(globalState.showNames && node.nodeType === 1) labelSpan.textContent = labelText + ': ';
    if(globalState.showNames && node.nodeType === 1) labelSpan.style.fontWeight = '600';
    li.appendChild(labelSpan);

    if(node.nodeType === 3){
      li.appendChild(document.createTextNode(node.nodeValue.trim()));
    } else {
      const textChild = Array.from(node.childNodes).filter(n=>n.nodeType===3 && n.nodeValue.trim())[0];
      if(textChild && childElements.every(n => n.nodeType === 3 || (n.nodeType === 1 && n.childNodes.length === 1 && n.childNodes[0].nodeType === 3))){
        li.appendChild(create('span', {}, textChild.nodeValue.trim()));
      } else {
        const subUL = create('ul', {cls:'tree'});
        childElements.forEach(ch => subUL.appendChild(build(ch)));
        li.appendChild(subUL);
        if(hasChildren){
          toggle.addEventListener('click', ()=> {
            li.classList.toggle('collapsed');
            toggle.textContent = toggle.textContent === '‚ñæ' ? '‚ñ∏' : '‚ñæ';
          });
        }
      }
    }
    if(node.nodeType === 1) li.setAttribute('data-gen-label', node.nodeName);
    return li;
  }
}

/* ===== Phonology rendering (human-friendly) ===== */
function renderPhonologyView(xmlDoc){
  const root = xmlDoc.documentElement;
  const container = create('div');
  container.appendChild(create('div', {cls:'section-title'}, 'Phonology Summary'));
  container.appendChild(create('div', {cls:'small-muted'}, `Version ${root.getAttribute('Version') || '‚Äî'} ‚Äî DefaultVernWs: ${root.getAttribute('DefaultVernWs') || '‚Äî'}`));

  // index phonemes
  globalState.phonemeIndex = {};
  const phonemes = Array.from(xmlDoc.getElementsByTagName('PhPhoneme') || []);
  phonemes.forEach(p => {
    const id = p.getAttribute('Id');
    const symbol = pickAUni(p.querySelector(':scope > Name')) || '';
    const desc = p.querySelector(':scope > Description Run')?.textContent?.trim() || '';
    const codes = Array.from(p.querySelectorAll(':scope > Codes PhCode Representation AUni')).map(a => a.textContent.trim()).filter(Boolean);
    globalState.phonemeIndex[id] = { id, symbol, desc, codes, node: p };
  });

  // phoneme sets / inventory
  const sets = Array.from(xmlDoc.getElementsByTagName('PhPhonemeSet') || []);
  sets.forEach(set => {
    const setName = pickAUni(set.querySelector(':scope > Name')) || 'Phoneme Set';
    const setDiv = create('div', {cls:'natclass'});
    setDiv.appendChild(create('div', {cls:'section-title'}, setName));
    const setDesc = set.querySelector(':scope > Description Run')?.textContent;
    if(setDesc) setDiv.appendChild(create('div', {cls:'small-muted'}, setDesc));

    const table = create('table', {cls:'phonemes'});
    table.innerHTML = '<thead><tr><th>Symbol</th><th>Description</th><th>ID</th><th>Codes</th></tr></thead>';
    const tbody = create('tbody');
    const rows = Array.from(set.querySelectorAll(':scope > Phonemes PhPhoneme')) || phonemes;
    rows.forEach(pnode => {
      const pid = pnode.getAttribute('Id');
      const data = globalState.phonemeIndex[pid] || {
        id: pid,
        symbol: pickAUni(pnode.querySelector(':scope > Name')) || '',
        desc: pnode.querySelector(':scope > Description Run')?.textContent || '',
        codes: Array.from(pnode.querySelectorAll(':scope > Codes PhCode Representation AUni')).map(a=>a.textContent.trim())
      };
      const row = create('tr', {id: 'phoneme-row-' + data.id});
      const symbolCell = create('td');
      const symBtn = create('span', {cls:'symbol-pill'}, data.symbol || '(no symbol)');
      symBtn.style.cursor = 'pointer';
      symBtn.addEventListener('click', ()=> onPhonemeSymbolClick(data.id));
      symbolCell.appendChild(symBtn);
      row.appendChild(symbolCell);
      row.appendChild(create('td', {}, data.desc || ''));
      row.appendChild(create('td', {}, data.id));
      row.appendChild(create('td', {}, (data.codes && data.codes.join(', ')) || ''));
      tbody.appendChild(row);
      globalState.phonemeRowIds[data.id] = row.id;
    });
    table.appendChild(tbody);
    setDiv.appendChild(table);

    // boundary markers
    const bMarkers = Array.from(set.querySelectorAll(':scope > BoundaryMarkers PhBdryMarker')) || [];
    if(bMarkers.length){
      setDiv.appendChild(create('div', {cls:'section-title'}, 'Boundary Markers'));
      const bmList = create('div', {cls:'small-muted'});
      bMarkers.forEach(bm => {
        const bmName = pickAUni(bm.querySelector(':scope > Name')) || bm.getAttribute('Id') || '';
        const bmCodes = Array.from(bm.querySelectorAll(':scope > Codes PhCode Representation AUni')).map(a=>a.textContent.trim()).filter(Boolean);
        bmList.appendChild(create('div', {}, `${bmName} ${ bmCodes.length ? '(' + bmCodes.join(', ') + ')' : ''}`));
      });
      setDiv.appendChild(bmList);
    }

    container.appendChild(setDiv);
  });

  // natural classes
  const ncs = Array.from(xmlDoc.getElementsByTagName('PhNCSegments') || []);
  if(ncs.length){
    container.appendChild(create('div', {cls:'section-title'}, 'Natural Classes'));
    ncs.forEach((nc, idx) => {
      const ncId = nc.getAttribute('Id') || ('nc-' + idx);
      const name = pickAUni(nc.querySelector(':scope > Name')) || nc.getAttribute('Id') || 'Unnamed';
      const abbr = pickAUni(nc.querySelector(':scope > Abbreviation')) || '';
      const desc = nc.querySelector(':scope > Description Run')?.textContent || '';
      const ncEl = create('div', {cls:'natclass', id: 'natclass-' + ncId});
      const title = create('div', {cls:'section-title'}, name + (abbr ? (' (' + abbr + ')') : ''));
      ncEl.appendChild(title);
      if(desc) ncEl.appendChild(create('div', {cls:'small-muted'}, desc));
      const segments = Array.from(nc.querySelectorAll(':scope > Segments')).map(s => s.getAttribute('dst')).filter(Boolean);
      const membersDiv = create('div', {cls:'members'});
      segments.forEach(sid => {
        const phon = globalState.phonemeIndex[sid];
        const text = phon ? (phon.symbol || phon.id) : sid;
        const pill = create('span', {cls:'symbol-pill'}, text);
        pill.addEventListener('click', ()=> {
          if(globalState.phonemeRowIds[sid]) scrollToAndHighlight(globalState.phonemeRowIds[sid]);
          else alert('Phoneme ID ' + sid + ' not found in phoneme index.');
        });
        membersDiv.appendChild(pill);
        if(!globalState.idToNatclassIds[sid]) globalState.idToNatclassIds[sid] = [];
        globalState.idToNatclassIds[sid].push(ncEl.id);
      });
      ncEl.appendChild(membersDiv);
      container.appendChild(ncEl);
      globalState.natclassElements[ncEl.id] = ncEl;
    });
  }

  // simple placeholders for Environments, Contexts, Rules
  const envs = Array.from(xmlDoc.getElementsByTagName('Environments') || []);
  envs.forEach(en => {
    const sec = create('div', {cls:'natclass'});
    sec.appendChild(create('div', {cls:'section-title'}, 'Environments'));
    sec.appendChild(en.hasChildNodes() ? renderGenericView(en) : create('div', {cls:'small-muted'}, '(no environment definitions)'));
    container.appendChild(sec);
  });
  const ctxs = Array.from(xmlDoc.getElementsByTagName('Contexts') || []);
  ctxs.forEach(c => {
    const sec = create('div', {cls:'natclass'});
    sec.appendChild(create('div', {cls:'section-title'}, 'Contexts'));
    sec.appendChild(c.hasChildNodes() ? renderGenericView(c) : create('div', {cls:'small-muted'}, '(no contexts defined)'));
    container.appendChild(sec);
  });

  // interactive behavior: clicking phoneme rows highlights natural classes
  Object.keys(globalState.phonemeRowIds).forEach(pid => {
    const rid = globalState.phonemeRowIds[pid];
    const row = document.getElementById(rid);
    if(row){
      row.addEventListener('click', ()=> {
        const natIds = globalState.idToNatclassIds[pid] || [];
        Object.values(globalState.natclassElements).forEach(el=> el.style.boxShadow = '');
        if(natIds.length){
          natIds.forEach(nid => {
            const el = globalState.natclassElements[nid];
            if(el){
              el.style.boxShadow = '0 0 0 3px rgba(11,110,219,0.08)';
              el.scrollIntoView({behavior:'smooth', block:'center'});
            }
          });
        } else {
          row.classList.add('highlight');
          setTimeout(()=> row.classList.remove('highlight'), 1200);
        }
      });
    }
  });

  return container;
}

/* ===== Wordforms export rendering (Card + Table + gloss language controls) ===== */
function renderWordformsView(xmlDoc){
  // root might be <wordforms> or something similar depending on export
  const root = xmlDoc.getElementsByTagName('wordforms')[0] || xmlDoc.documentElement;
  const container = create('div');
  container.appendChild(create('div', {cls:'section-title'}, 'Wordforms'));

  // collect all wordform nodes
  // FieldWorks samples may use <wordform> children
  const wfNodes = Array.from(root.getElementsByTagName('wordform'));
  // fallback: maybe root contains <Wordform> nodes
  if(wfNodes.length === 0){
    const alt = Array.from(root.getElementsByTagName('WordForm')).concat(Array.from(root.getElementsByTagName('Wordform')));
    if(alt.length) wfNodes.push(...alt);
  }

  // scan for gloss languages across all gloss elements
  const glossElems = Array.from(xmlDoc.querySelectorAll('gloss[ws], gloss AUni[ws], glosses gloss[ws]')) // flexible
    .concat(Array.from(xmlDoc.querySelectorAll('gloss'))); // fallback
  const glossLangsSet = new Set();
  glossElems.forEach(g => {
    if(g.getAttribute && g.getAttribute('ws')) glossLangsSet.add(g.getAttribute('ws'));
    else {
      // also accept <gloss><AUni ws="..."> or similar
      const auni = g.querySelector && g.querySelector('AUni[ws]');
      if(auni) glossLangsSet.add(auni.getAttribute('ws'));
    }
  });
  const glossLangs = Array.from(glossLangsSet);
  glossLangs.sort((a,b)=> a.toLowerCase().includes('en')? -1 : a.localeCompare(b));

  // load wordform prefs (view mode + gloss languages visibility)
  const saved = loadJSON(WORDFORM_PREFS_KEY) || {};
  let viewMode = saved.viewMode || 'card'; // 'card' or 'table'
  let glossPrefs = saved.glossPrefs || {};
  // init prefs from discovered glossLangs
  glossLangs.forEach((ws,i) => {
    if(typeof glossPrefs[ws] !== 'object') glossPrefs[ws] = { ws, visible: true, order: i };
  });

  // UI controls
  const controls = create('div', {cls:'controls-inline'});
  const viewToggle = create('button', {cls:'small-btn', title:'Toggle Card/Table view'}, viewMode === 'card' ? 'Switch to Table View üìã' : 'Switch to Card View üóÇÔ∏è');
  controls.appendChild(viewToggle);

  // gloss language chooser (only shown in Table view)
  const glossChooser = create('div', {cls:'small-muted'});
  glossChooser.style.display = viewMode === 'table' ? 'block' : 'none';
  glossChooser.style.paddingLeft = '8px';
  glossChooser.style.marginLeft = '8px';
  glossChooser.textContent = 'Gloss languages: ';
  glossLangs.forEach(ws => {
    const label = create('label');
    label.style.marginRight = '8px';
    const cb = create('input'); cb.type = 'checkbox'; cb.checked = glossPrefs[ws].visible; cb.dataset.ws = ws;
    cb.addEventListener('change', () => {
      glossPrefs[ws].visible = cb.checked; saveJSON(WORDFORM_PREFS_KEY, { viewMode, glossPrefs }); renderItems();
    });
    label.appendChild(cb);
    label.appendChild(document.createTextNode(' ' + ws));
    glossChooser.appendChild(label);
  });

  controls.appendChild(glossChooser);
  container.appendChild(controls);

  // search/filter input (helpful)
  const searchRow = create('div', {cls:'small-muted'});
  searchRow.style.marginTop = '8px';
  searchRow.innerHTML = 'Filter: <input id="wf_search" placeholder="search form or gloss..." style="padding:4px;border-radius:4px;border:1px solid #ddd;margin-left:6px;">';
  container.appendChild(searchRow);

  const listArea = create('div');
  listArea.style.marginTop = '8px';
  container.appendChild(listArea);

  // wire view toggle
  viewToggle.addEventListener('click', ()=>{
    viewMode = viewMode === 'card' ? 'table' : 'card';
    saveJSON(WORDFORM_PREFS_KEY, { viewMode, glossPrefs });
    viewToggle.textContent = viewMode === 'card' ? 'Switch to Table View üìã' : 'Switch to Card View üóÇÔ∏è';
    glossChooser.style.display = viewMode === 'table' ? 'block' : 'none';
    renderItems();
  });

  // render items either card or table
  function renderItems(){
    listArea.innerHTML = '';
    const q = (byId('wf_search')?.value || '').trim().toLowerCase();

    // helper to collect form text, glosses, category, counts
    function extractData(wf){
      const forms = [];
      // FieldWorks uses <form ws="..."> inside wordform ‚Äî but samples vary. We'll be flexible.
      const formNodes = Array.from(wf.querySelectorAll('form, Form, word'));
      if(formNodes.length === 0){
        // try direct text
        const txt = (wf.textContent || '').trim();
        if(txt) forms.push({ws:'', text: txt});
      } else {
        formNodes.forEach(fn => {
          // look for AUni children if present
          const aunis = fn.querySelectorAll && fn.querySelectorAll('AUni');
          if(aunis && aunis.length){
            aunis.forEach(a => forms.push({ ws: a.getAttribute('ws') || '', text: (a.textContent||'').trim() }));
          } else {
            const ws = fn.getAttribute && fn.getAttribute('ws') || '';
            const t = (fn.textContent || '').trim();
            if(t) forms.push({ ws, text: t });
          }
        });
      }

      // analyses -> gloss, category, counts
      const analyses = Array.from(wf.querySelectorAll('analysis, Analysis'));
      const glosses = []; // array of {ws,text}
      const categories = [];
      analyses.forEach(a => {
        const gNodes = Array.from(a.querySelectorAll('gloss, Gloss'));
        if(gNodes.length){
          gNodes.forEach(gn => {
            const aun = gn.querySelector && gn.querySelector('AUni[ws]');
            if(aun) glosses.push({ ws: aun.getAttribute('ws') || '', text: (aun.textContent||'').trim() });
            else {
              const ws = gn.getAttribute && gn.getAttribute('ws') || '';
              const t = (gn.textContent || '').trim();
              if(t) glosses.push({ ws, text: t });
            }
          });
        }
        const cat = a.querySelector('category, Category')?.textContent?.trim();
        if(cat) categories.push(cat);
      });

      // counts
      const predicted = parseInt(wf.getAttribute('PredictedAnalyses') || wf.getAttribute('predictedanalyses') || wf.querySelector('PredictedAnalyses')?.textContent || '0') || 0;
      const user = parseInt(wf.getAttribute('UserAnalyses') || wf.getAttribute('useranalyses') || wf.querySelector('UserAnalyses')?.textContent || '0') || 0;

      return { forms, glosses, categories, predicted, user, node: wf };
    }

    const dataList = wfNodes.map(wf => extractData(wf));

    // apply search filter: matches form text or any gloss text
    const filtered = dataList.filter(d => {
      if(!q) return true;
      const formMatch = d.forms.some(f => (f.text||'').toLowerCase().includes(q));
      const glossMatch = d.glosses.some(g => (g.text||'').toLowerCase().includes(q));
      const catMatch = d.categories.some(c => (c||'').toLowerCase().includes(q));
      return formMatch || glossMatch || catMatch;
    });

    if(viewMode === 'card'){
      // Card view
      filtered.forEach(d => {
        const card = create('div', {cls:'wordform-card'});
        const header = create('div', {cls:'wordform-header'});
        const main = create('div');
        const primaryForm = d.forms[0]?.text || '(no form)';
        main.appendChild(create('div', {cls:'wordform-main'}, primaryForm));
        main.appendChild(create('div', {cls:'wordform-meta'}, `Predicted: ${d.predicted} ¬∑ User: ${d.user}`));
        header.appendChild(main);
        // small expand button (collapse/expand body)
        const expBtn = create('button', {cls:'small-btn', title:'Toggle details'}, '‚ñæ');
        header.appendChild(expBtn);
        card.appendChild(header);

        const body = create('div', {cls:'wordform-body'});
        if(d.glosses.length === 0 && d.categories.length === 0){
          body.appendChild(create('div', {cls:'small-muted'}, '‚Äî No analysis ‚Äî'));
        } else {
          // group glosses by ws
          const byWs = {};
          d.glosses.forEach(g => { if(!byWs[g.ws]) byWs[g.ws] = []; byWs[g.ws].push(g.text); });
          Object.keys(byWs).forEach(ws => {
            const line = create('div');
            line.innerHTML = `<strong>Gloss (${escapeHtml(ws)}):</strong> ${escapeHtml(byWs[ws].join('; '))}`;
            body.appendChild(line);
          });
          if(d.categories.length){
            body.appendChild(create('div', {}, `Category: ${escapeHtml(d.categories.join('; '))}`));
          }
        }
        body.style.display = 'block';
        expBtn.addEventListener('click', ()=> {
          body.style.display = body.style.display === 'none' ? 'block' : 'none';
          expBtn.textContent = expBtn.textContent === '‚ñæ' ? '‚ñ∏' : '‚ñæ';
        });
        card.appendChild(body);
        listArea.appendChild(card);
      });
    } else {
      // Table view: show selected gloss columns based on glossPrefs
      const visibleGlossLangs = glossLangs.filter(ws => glossPrefs[ws] && glossPrefs[ws].visible);
      const table = create('table', {cls:'table-view'});
      // build header
      const thead = create('thead');
      const headerRow = create('tr');
      headerRow.appendChild(create('th', {}, 'Wordform'));
      visibleGlossLangs.forEach(ws => headerRow.appendChild(create('th', {}, `Gloss (${ws})`)));
      headerRow.appendChild(create('th', {}, 'Category'));
      headerRow.appendChild(create('th', {}, 'Pred'));
      headerRow.appendChild(create('th', {}, 'User'));
      thead.appendChild(headerRow);
      table.appendChild(thead);
      const tbody = create('tbody');
      filtered.forEach(d => {
        const tr = create('tr');
        const primaryForm = d.forms[0]?.text || '(no form)';
        tr.appendChild(create('td', {}, primaryForm));
        visibleGlossLangs.forEach(ws => {
          const text = d.glosses.filter(g=>g.ws === ws).map(g=>g.text).join('; ') || '‚Äî';
          tr.appendChild(create('td', {}, text));
        });
        tr.appendChild(create('td', {}, d.categories.join('; ') || '‚Äî'));
        tr.appendChild(create('td', {}, String(d.predicted)));
        tr.appendChild(create('td', {}, String(d.user)));
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      listArea.appendChild(table);
    }
  }

  // initial render
  renderItems();

  // wire search input
  const searchInput = byId('wf_search');
  if(searchInput){
    searchInput.addEventListener('input', () => { renderItems(); });
  }

  // wire gloss chooser UI to persist prefs
  // already wired by checkboxes earlier when created, but ensure persistence for viewMode state
  // save viewMode & glossPrefs whenever changed
  function persistWordformPrefs(){ saveJSON(WORDFORM_PREFS_KEY, { viewMode, glossPrefs }); }
  // update glossPrefs reference to the variable used by event handlers above
  // ensure glossPrefs is synced with UI checkbox states if user toggles view toggle
  // done through event handlers above that call saveJSON directly.

  return container;
}

/* ===== Utilities used by phonology rendering ===== */
function pickAUni(node){
  if(!node) return '';
  const aunis = Array.from(node.querySelectorAll('AUni'));
  if(aunis.length === 0) {
    const t = node.textContent && node.textContent.trim();
    return t || '';
  }
  for(const a of aunis){ const ws = (a.getAttribute('ws')||'').toLowerCase(); if(ws.includes('fau')) return a.textContent.trim(); }
  for(const a of aunis){ const ws = (a.getAttribute('ws')||'').toLowerCase(); if(ws.includes('en')) return a.textContent.trim(); }
  return aunis[0].textContent.trim();
}

/* ===== Click helpers ===== */
function onPhonemeSymbolClick(phonId){
  const rowId = globalState.phonemeRowIds[phonId];
  if(!rowId){ alert('Phoneme entry not found: ' + phonId); return; }
  scrollToAndHighlight(rowId);
}
function scrollToAndHighlight(rowId){
  const el = document.getElementById(rowId);
  if(!el) return;
  document.querySelectorAll('tr.highlight').forEach(r=> r.classList.remove('highlight'));
  el.classList.add('highlight');
  el.scrollIntoView({behavior:'smooth', block:'center'});
  el.classList.add('scroll-target');
  setTimeout(()=> el.classList.remove('scroll-target'), 2200);
}

/* ===== Build standalone HTML (for open/save) ‚Äî note escaped closing tag to avoid template literal issues ===== */
function buildStandaloneHTML(){
  const render = byId('renderArea');
  // Gather prologue (if any) + current render content (without duplicating prologue)
  let content = '';
  const prologueNode = render.querySelector(':scope > .chart-prologue');
  const clone = render.cloneNode(true);
  // Helper: ensure destination table has individual <col> elements (no span)
  function ensureIndividualCols(tbl){
    const groups = Array.from(tbl.querySelectorAll('colgroup'));
    groups.forEach(g=>{
      const c = g.querySelector('col');
      if(!c) return;
      const span = Number(c.getAttribute('span')||'1');
      if(span > 1){
        c.removeAttribute('span');
        const frag = document.createDocumentFragment();
        for(let i=0;i<span;i++) frag.appendChild(document.createElement('col'));
        g.replaceChild(frag, c);
      }
    });
  }
  // Helper: freeze current column widths from live table into the cloned table
  function freezeChartColumnWidthsInClone(sourceRoot, cloneRoot){
    const srcTbl = sourceRoot.querySelector('table.chartshell');
    const dstTbl = cloneRoot.querySelector('table.chartshell');
    if(!srcTbl || !dstTbl) return;
    // Make sure destination has one <col> per column
    ensureIndividualCols(dstTbl);
    const dstCols = Array.from(dstTbl.querySelectorAll('col'));
    if(!dstCols.length) return;
    // Build widths array by measuring header (prefer title2), then fill from body rows as needed
    const widths = new Array(dstCols.length).fill(0);
    const srcHeader = srcTbl.querySelector('tr.row.title2') || srcTbl.querySelector('tr.row.title1');
    let colIndex = 0;
    if(srcHeader){
      srcHeader.querySelectorAll('th.cell').forEach(th=>{
        const span = Number(th.getAttribute('colspan')||'1');
        const w = Math.max(0, Math.round(th.getBoundingClientRect().width));
        const per = Math.max(0, Math.floor(w / span));
        for(let i=0;i<span && (colIndex + i) < widths.length;i++){
          widths[colIndex + i] = per;
        }
        colIndex += span;
      });
    }
    const srcBodyRows = Array.from(srcTbl.querySelectorAll('tbody tr'));
    function fillFromRow(row){
      let idx = 0;
      Array.from(row.children).forEach(td=>{
        const span = Number(td.getAttribute('colspan')||'1');
        const w = Math.max(0, Math.round(td.getBoundingClientRect().width));
        const per = Math.max(0, Math.floor(w / span));
        for(let i=0;i<span && (idx + i) < widths.length;i++){
          if(widths[idx + i] === 0) widths[idx + i] = per;
        }
        idx += span;
      });
    }
    if(widths.some(v=>v===0) && srcBodyRows.length){
      for(let r=0; r<Math.min(10, srcBodyRows.length); r++){
        fillFromRow(srcBodyRows[r]);
        if(!widths.some(v=>v===0)) break;
      }
    }
    // Apply a floor and assign to destination <col> style.width
    for(let i=0;i<widths.length;i++){
      const px = Math.max(40, widths[i] || 0);
      if(dstCols[i]) dstCols[i].style.width = px + 'px';
    }
    // Enforce fixed layout so widths render consistently in the export
    dstTbl.style.tableLayout = 'fixed';
    dstTbl.style.width = 'auto';
    dstTbl.style.maxWidth = '100%';
  }
  // Freeze widths before stripping interactive bits
  try{ freezeChartColumnWidthsInClone(render, clone); }catch(_){ /* non-fatal */ }
  // Strip interactive resize handles from export
  clone.querySelectorAll('.col-resizer').forEach(el=> el.remove());
  // Also clear any resizable flags to avoid styling hooks
  clone.querySelectorAll('table.chartshell[data-resizable]')
    .forEach(tbl=> tbl.removeAttribute('data-resizable'));
  if(prologueNode){
    content += prologueNode.outerHTML; // put prologue first
    const cPrologue = clone.querySelector(':scope > .chart-prologue');
    if(cPrologue) cPrologue.remove(); // remove from rest of content
  }
  content += clone.innerHTML;

  // Pick a title for the export: prefer H1 from prologue, then any heading/div/p, else fallback
  let exportTitle = 'FLEx XML View Export';
  if (prologueNode) {
    const h1 = prologueNode.querySelector('h1');
    const anyHead = prologueNode.querySelector('h1,h2,h3,h4,h5,h6,div,p');
    const titleNode = h1 || anyHead;
    if (titleNode && titleNode.textContent) {
      const t = titleNode.textContent.replace(/\s+/g, ' ').trim();
      if (t) exportTitle = t;
    }
  }
  // Collect all current styles from <head> including any injected at runtime
  function collectCurrentHeadCSS(){
    let css = '';
    // Inline <style> tags in order
    document.head.querySelectorAll('style').forEach((s, idx)=>{
      const label = s.id ? `style#${s.id}` : `style[${idx}]`;
      css += `\n/* ${label} */\n` + (s.textContent || '') + '\n';
    });
    // Attempt to inline same-origin linked stylesheets
    Array.from(document.styleSheets || []).forEach(ss => {
      try{
        // Only include sheets originating from a <link> node we can read
        if(ss && ss.ownerNode && ss.ownerNode.tagName === 'LINK' && ss.cssRules){
          css += `\n/* linked stylesheet: ${ss.href || ''} */\n`;
          for(const rule of ss.cssRules){ css += rule.cssText + '\n'; }
        }
      }catch(e){ /* likely a cross-origin stylesheet; skip */ }
    });
    return css.trim();
  }
  const headCSS = collectCurrentHeadCSS();
  const doc = `<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>${escapeHtml(exportTitle)}</title>
<style>${headCSS}\n</style>
</head>
<body>
${content}
<script>
  document.querySelectorAll('.toggle').forEach(t=> {
    const parent = t.parentElement;
    t.addEventListener('click', ()=> {
      parent.classList.toggle('collapsed');
      t.textContent = t.textContent === '‚ñæ' ? '‚ñ∏' : '‚ñæ';
    });
  });
  document.querySelectorAll('.symbol-pill').forEach(p=> {
    p.addEventListener('click', ()=> {
      const txt = p.textContent.trim();
      const rows = document.querySelectorAll('table.phonemes tbody tr');
      for(const r of rows){
        if(r.cells[0] && r.cells[0].textContent.trim() === txt){
          r.scrollIntoView({behavior:'smooth', block:'center'});
          r.classList.add('highlight');
          setTimeout(()=> r.classList.remove('highlight'), 1800);
          return;
        }
      }
    });
  });
  // Note: Resizing is intentionally disabled in exported files.
<\/script>
</body>
</html>`;
  return doc;
}

/* ===== Column resizing for Text Chart in-app ===== */
function expandColgroupsToIndividualCols(tbl){
  const groups = Array.from(tbl.querySelectorAll('colgroup'));
  groups.forEach(g=>{
    const c = g.querySelector('col');
    if(!c) return;
    const span = Number(c.getAttribute('span')||'1');
    if(span > 1){
      c.removeAttribute('span');
      const frag = document.createDocumentFragment();
      for(let i=0;i<span;i++) frag.appendChild(document.createElement('col'));
      g.replaceChild(frag, c);
    }
  });
}
function addResizeHandles(tbl){
  const header2 = tbl.querySelector('tr.row.title2');
  const header = header2 || tbl.querySelector('tr.row.title1');
  if(!header) return;
  let colIndex = 0;
  const groups = Array.from(tbl.querySelectorAll('colgroup'));
  const allCols = groups.flatMap(g => Array.from(g.querySelectorAll('col')));
  header.querySelectorAll('th.cell').forEach(th=>{
    const span = Number(th.getAttribute('colspan')||'1');
    const targetColEnd = colIndex + span - 1;
    const handle = document.createElement('div');
    handle.className = 'col-resizer';
    handle.title = 'Drag to resize column';
    handle.dataset.colEnd = String(targetColEnd);
    th.appendChild(handle);
    wireHandleDrag(handle, allCols);
    colIndex += span;
  });
}
function wireHandleDrag(handle, allCols){
  let startX = 0, startWidth = 0, colEl = null;
    function computeMinColWidth(tbl, idx){
      let minW = 40;
      const rows = Array.from(tbl.querySelectorAll('tbody tr')).slice(0, 200);
      rows.forEach(row=>{
        let ci = 0; let cell = null;
        Array.from(row.children).some(td=>{
          const sp = Number(td.getAttribute('colspan')||'1');
          const covers = (idx >= ci) && (idx < ci + sp);
          ci += sp; if(covers){ cell = td; return true; } return false;
        });
        if(cell){
          let pairs = cell.querySelectorAll('.interlinear .pair:not(.note)');
          if(!pairs.length) pairs = cell.querySelectorAll('.interlinear .pair');
          pairs.forEach(p=>{ const w = Math.ceil(p.getBoundingClientRect().width); if(w > minW) minW = w; });
        }
      });
      return Math.max(40, minW);
    }
  function onMove(e){
    const dx = e.clientX - startX;
      const tbl = handle.closest('table');
      const idx = Number(handle.dataset.colEnd||'0');
      const minAllowed = computeMinColWidth(tbl, idx);
      const newW = Math.max(minAllowed, startWidth + dx);
    colEl.style.width = newW + 'px';
    handle.classList.add('dragging');
  }
  function onUp(){
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    handle.classList.remove('dragging');
  }
  handle.addEventListener('mousedown', (e)=>{
    e.preventDefault();
    const idx = Number(handle.dataset.colEnd||'0');
    colEl = allCols[idx];
    if(!colEl) return;
    const tbl = handle.closest('table');
    const bodyRow = tbl.querySelector('tbody tr');
    let probeCell = null;
    if(bodyRow){
      let ci = 0; probeCell = Array.from(bodyRow.children).find(td=>{
        const sp = Number(td.getAttribute('colspan')||'1');
        const covers = (idx >= ci) && (idx < ci + sp);
        ci += sp; return covers;
      });
    }
    const rect = (probeCell || handle.parentElement).getBoundingClientRect();
    if(!colEl.style.width){ colEl.style.width = Math.max(40, Math.round(rect.width)) + 'px'; }
    startX = e.clientX;
    startWidth = parseFloat(colEl.style.width) || Math.max(40, Math.round(rect.width));
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });
}
function enableTextChartColumnResize(root){
  const tbl = (root instanceof Element ? root : document).querySelector('table.chartshell');
  if(!tbl || tbl.dataset.resizable === '1') return;
  expandColgroupsToIndividualCols(tbl);
  addResizeHandles(tbl);
  tbl.dataset.resizable = '1';
    tbl.style.tableLayout = 'fixed';
    tbl.style.width = 'auto';
    tbl.style.maxWidth = '100%';
}
</script>
</body>
</html>