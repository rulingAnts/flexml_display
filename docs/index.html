<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FLExText Discourse Analysis Tool (FDAT) (and FLEx XML Viwer/Exporter)</title>
<style>
  :root{
    --accent:#0b6edb;
    --muted:#6c6c6c;
    --bg:#fbfbfb;
    --card:#fff;
    --border:#e2e2e2;
    --highlight:#fff2b8;
  }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:18px;background:var(--bg);color:#111}
  header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  h1{font-size:1.1rem;margin:0}
  textarea{width:720px;max-width:100%;height:220px;font-family:monospace;padding:8px;border:1px solid var(--border);border-radius:6px;background:linear-gradient(#fff,#fcfcfc)}
  input[type=file]{padding:6px}
  button{background:var(--accent);color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer}
  button.secondary{background:#ddd;color:#111}
  .small-btn{padding:4px 8px;font-size:0.85rem;border-radius:6px}
  .viewer{margin-top:18px;background:var(--card);border:1px solid var(--border);padding:14px;border-radius:8px;box-shadow:0 1px 0 rgba(0,0,0,0.03)}
  /* Expand the white card to fit wide content so the browser handles scrollbars */
  .viewer{width:max-content;min-width:100%}
  /* Override XSL's table width:100% so it can define its natural width */
  .viewer .chartshell{width:max-content}
  /* Column resize UI for Text Chart tables */
  .chartshell th{position:relative}
  .col-resizer{position:absolute;top:0;right:0;width:8px;cursor:col-resize;user-select:none;height:100%}
  .col-resizer:after{content:"";position:absolute;top:0;bottom:0;left:2px;width:2px;background:transparent}
  .col-resizer.dragging:after{background:rgba(11,110,219,0.35)}
  /* Make content wrap when columns shrink (resizable mode switches table-layout to fixed) */
  .chartshell th, .chartshell td{overflow-wrap:anywhere; word-break:normal; min-width:0}
  /* Sticky (freeze) header rows for Text Chart */
  .chartshell.freeze-headers{ border-collapse: separate; border-spacing: 0; }
  /* Prefer row-level sticky for Firefox */
  .chartshell.freeze-headers thead tr.row.title1,
  .chartshell.freeze-headers thead tr.row.title2{
    position: sticky;
  }
  .chartshell.freeze-headers thead tr.row.title1 th,
  .chartshell.freeze-headers thead tr.row.title2 th{
    position: sticky;
    z-index: 3;
    background: #fff;
  }
  .chartshell.freeze-headers thead tr.row.title1{ top: var(--tc-sticky-top-1, 0px); }
  .chartshell.freeze-headers thead tr.row.title2{ top: var(--tc-sticky-top-2, 32px); }
  .chartshell.freeze-headers thead tr.row.title1 th{ top: var(--tc-sticky-top-1, 0px); }
  .chartshell.freeze-headers thead tr.row.title2 th{ top: var(--tc-sticky-top-2, 32px); }
  /* Ensure borders render above body cells */
  .chartshell.freeze-headers thead tr.row.title1{ z-index: 950; }
  .chartshell.freeze-headers thead tr.row.title2{ z-index: 951; }
  .chartshell.freeze-headers thead tr.row.title2 th{ z-index: 952; }
  /* Free translations UI (viewer) */
  .add-trans-btn{ margin-left:6px; font-size:0.75rem; padding:2px 6px; border:1px solid #e0e0e0; background:#fff; color:#333; border-radius:6px; cursor:pointer }
  .add-trans-btn:hover{ background:#f6f8ff; border-color:#cfe0ff }
  /* Salience band row button */
  .add-band-btn{ margin-left:6px; font-size:0.75rem; padding:2px 6px; border:1px solid #e0e0e0; background:#fff; color:#333; border-radius:6px; cursor:pointer }
  .add-band-btn:hover{ background:#f6f8ff; border-color:#cfe0ff }
  /* Inline free translation row */
  .ft-inline{ background:#fbfcff }
  .ft-inline td{ color: var(--ft-inline-color, #333); font-size: var(--ft-inline-font-size, 0.95rem); background: var(--ft-inline-bg, #fbfcff); padding-top:6px; padding-bottom:6px; border-top:0 }
  .ft-inline .ft-label{ font-weight:600; color:#4b5563; margin-right:6px }
  /* Tooltip link marker for Free Translations */
  .ft-link{ margin-left:6px; text-decoration:none; color:#0b6edb }
  .ft-link sup{ font-weight:600 }
  /* Free Translations section (export, tooltip mode) */
  .chart-freetrans{ border:1px solid #eee; padding:8px 10px; border-radius:6px; background:linear-gradient(#fff,#fafdff); margin:12px 0 }
  .chart-freetrans h3{ margin:0 0 8px 0; font-size:1rem }
  .chart-freetrans .ft-item{ display:grid; grid-template-columns:80px 1fr; gap:6px 10px; padding:6px 0; border-top:1px solid #f0f0f0 }
  .chart-freetrans .ft-item:first-of-type{ border-top:none }
  .chart-freetrans .ft-label{ font-weight:600 }
  .chartshell-wrapper{ position: relative; }
  .chartshell-sticky-spacer{ height: var(--tc-sticky-spacer, 0px); }
    /* Simple modal for text input (used by Free Translations) */
    .modal-overlay{ position:fixed; inset:0; background:rgba(0,0,0,0.3); z-index:99999; display:flex; align-items:center; justify-content:center; }
    .modal{ background:#fff; border:1px solid #e5e5e5; border-radius:10px; padding:12px; width:min(520px, 90vw); box-shadow:0 12px 32px rgba(0,0,0,0.2) }
    .modal h3{ margin:0 0 8px 0; font-size:1rem }
    .modal textarea{ width:100%; min-height:110px; padding:8px; border:1px solid #e5e5e5; border-radius:6px; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
    .modal-actions{ margin-top:8px; display:flex; gap:8px; justify-content:flex-end }
  /* Interlinear pair layout is defined by XSL-injected <style>; avoid overriding here. */
  .controls-row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:8px}
  .prologue-panel{display:none;margin-top:10px;background:#f7fbff;border:1px solid #d9ebff;padding:10px 12px;border-radius:8px}
  /* About panel is always visible on load (non-persistent collapsible) */
  #aboutPanel{display:block}
  .prologue-grid{display:grid;grid-template-columns:140px 1fr;gap:8px 10px;align-items:center}
  .prologue-grid .full{grid-column:1 / -1}
  .prologue-grid input[type=text]{width:100%;padding:6px;border:1px solid var(--border);border-radius:6px}
  .prologue-grid select{padding:6px;border:1px solid var(--border);border-radius:6px}
  .prologue-grid textarea{width:100%;min-height:80px}
  .section-title{font-weight:600;margin:8px 0;font-size:1rem}
  ul.tree{list-style:none;margin:6px 0 6px 14px;padding-left:10px;border-left:1px dotted #ddd}
  ul.tree li{margin:4px 0;position:relative;padding-left:6px}
  .toggle{user-select:none;cursor:pointer;margin-right:6px;color:var(--accent)}
  .collapsed > ul{display:none}
  .label{font-weight:600;margin-right:6px}
  .muted{color:var(--muted);font-size:0.95rem}
  table.phonemes{width:100%;border-collapse:collapse;margin-top:8px}
  table.phonemes th, table.phonemes td{padding:8px;border-bottom:1px solid #eee;text-align:left}
  tr.highlight{background:var(--highlight) !important}
  .natclass{border:1px solid var(--border);padding:8px;border-radius:6px;margin-bottom:10px;background:linear-gradient(#fff,#f9f9f9)}
  .natclass .members{margin-top:8px;display:flex;flex-wrap:wrap;gap:8px}
  .symbol-pill{background:#f1f8ff;border:1px solid #d6eaff;padding:3px 7px;border-radius:6px;cursor:pointer}
  .symbol-pill:hover{background:#e8f2ff}
  .small-muted{font-size:0.9rem;color:var(--muted)}
  .translation-main{font-weight:600}
  .translation-others{color:var(--muted);margin-left:6px;font-size:0.95rem}
  .lang-controls{display:flex;align-items:center;gap:8px;margin:6px 0 12px 0;flex-wrap:wrap}
  .lang-controls .lang-item{display:flex;align-items:center;gap:6px;padding:4px}
  .icon-btn{background:#fff;border:1px solid #e0e0e0;padding:5px 7px;border-radius:6px;cursor:pointer}
  .wordform-card{border:1px solid #e6e6e6;padding:10px;border-radius:8px;margin-bottom:8px;background:linear-gradient(#fff,#fcfcff)}
  .wordform-header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  .wordform-main{font-weight:700;font-size:1.05rem}
  .wordform-meta{color:var(--muted);font-size:0.9rem}
  .wordform-body{margin-top:8px}
  /* Abbreviations UI and rendered block */
  .abbrev-panel{display:none;margin-top:10px;background:#fff8f0;border:1px solid #ffe2bf;padding:10px 12px;border-radius:8px}
  .abbrev-grid{display:grid;grid-template-columns:160px 1fr;gap:8px 10px;align-items:center}
  .abbrev-grid input[type=text]{width:100%;padding:6px;border:1px solid var(--border);border-radius:6px}
  .abbrev-grid .rows{grid-column:1 / -1}
  .abbr-row{display:grid;grid-template-columns:auto 1fr 2fr;gap:8px;margin-bottom:6px;align-items:center}
  .abbr-row input{min-width:0}
  .abbr-abbr{font-family:monospace;padding:4px 6px;border:1px solid #e5e5e5;border-radius:6px;background:#f7f7f7;white-space:nowrap}
  .chart-abbrev-block{border:1px solid #eee;padding:8px 10px;border-radius:6px;background:linear-gradient(#fff,#fcfcf8);margin:10px 0}
  .chart-abbrev-block h3{margin:0 0 6px 0;font-size:1rem}
  .chart-abbrev-block ul{margin:0;padding-left:18px}
  .chart-abbrev-block li{margin:3px 0}
  /* ListRef controls panel */
  .listref-panel{display:none;margin-top:10px;background:#f4fff4;border:1px solid #cfe9cf;padding:10px 12px;border-radius:8px}
  .listref-grid{display:grid;grid-template-columns:160px 1fr;gap:8px 10px;align-items:center}
  .listref-grid .rows{grid-column:1 / -1}
  .lr-row{display:grid;grid-template-columns:auto auto auto 1fr;gap:8px;margin-bottom:6px;align-items:center}
  .lr-row .lr-abbr{font-family:monospace;padding:4px 6px;border:1px solid #e5e5e5;border-radius:6px;background:#f7f7f7;white-space:nowrap}
  .lr-row .lr-abbr.is-hidden{color:#9a9a9a;text-decoration:line-through}
  .lr-row .lr-chip{background:#eef8ee;border:1px solid #dcefdc;padding:2px 6px;border-radius:999px;font-size:0.85rem}
  .lr-row button{min-width:28px}
  /* Collapsible panels */
  .collapsible-header{display:flex;align-items:center;gap:8px;cursor:pointer;user-select:none;font-weight:600;margin:2px 0}
  .collapsible-header .chev{margin-left:auto;color:var(--muted)}
  .collapsible-body{margin-top:8px}
  #prologuePanel[data-collapsed="1"] .collapsible-body,
  #abbrevPanel[data-collapsed="1"] .collapsible-body,
  #appendHtmlPanel[data-collapsed="1"] .collapsible-body,
  #listRefPanel[data-collapsed="1"] .collapsible-body,
  #postloguePanel[data-collapsed="1"] .collapsible-body,
  #notesPanel[data-collapsed="1"] .collapsible-body,
  #saliencePanel[data-collapsed="1"] .collapsible-body,
  #ftPanel[data-collapsed="1"] .collapsible-body,
  #aboutPanel[data-collapsed="1"] .collapsible-body{display:none}
  /* Grouping UI */
  .lr-group{border:1px solid #dcefdc;background:#f8fff8;border-radius:6px;padding:8px;margin-bottom:8px}
  .lr-group-header{display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:6px}
  .lr-group-items{margin-left:24px}
  /* Inserted external HTML blocks */
  .inserted-html-before-prologue, .inserted-html-after-chart{border:1px solid #eee;padding:8px 10px;border-radius:6px;background:#fff; margin:10px 0}
  .table-view{width:100%;border-collapse:collapse}
  .table-view th,.table-view td{padding:8px;border-bottom:1px solid #eee;text-align:left}
  .controls-inline{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  footer{margin-top:28px;padding-top:10px;border-top:1px solid #e6e6e6;color:var(--muted);font-size:0.9rem}
  /* Endnotes container tweaks */
  .chart-endnotes{border:1px solid #eee;padding:8px 10px;border-radius:6px;background:linear-gradient(#fff,#fcfcff);margin:12px 0}
  /* Salience Bands panel styles */
  .salience-tree{ list-style:none; margin:6px 0; padding-left:0 }
  .sal-item{ display:flex; align-items:center; gap:8px; margin:4px 0 }
  .sal-indent{ width: var(--sal-indent, 0px); flex:0 0 auto }
  .sal-num{ font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; font-weight:600; min-width:44px }
  .sal-color{ width:16px; height:16px; border-radius:4px; border:1px solid #ddd; display:inline-block }
  .salience-controls{ display:flex; align-items:center; gap:6px; flex-wrap:wrap }
  .salience-controls input[type="text"]{ padding:4px 6px; border:1px solid #e5e5e5; border-radius:6px; min-width:160px }
  .salience-controls input[type="color"]{ padding:0; border:1px solid #e5e5e5; border-radius:6px; width:36px; height:28px }
  .sal-btn{ background:#fff; border:1px solid #e0e0e0; padding:4px 6px; border-radius:6px; cursor:pointer }
  .sal-btn:hover{ background:#f6f8ff; border-color:#cfe0ff }
  /* Salience column and legend */
  .sal-cell{ white-space:nowrap; font-size:0.9rem; border-right:1px solid #eee; padding:4px 6px; min-width:8ch }
  .sal-pill{ display:inline-block; padding:1px 6px; border-radius:999px; border:1px solid #e0e0e0; background:#fff; color:#333; font-size:0.85rem }
  .chart-salience-legend{ border:1px solid #eee; padding:8px 10px; border-radius:6px; background:linear-gradient(#fff,#fafdff); margin:10px 0 }
  .chart-salience-legend h3{ margin:0 0 6px 0; font-size:1rem }
  .chart-salience-legend .sal-row{ display:flex; align-items:center; gap:10px; padding:4px 0; border-top:1px solid #f3f3f3 }
  .chart-salience-legend .sal-row:first-of-type{ border-top:none }
  @media print {
    .chart-endnotes { break-before: page; page-break-before: always; }
  }
  /* HTML tooltip for endnote previews */
  .note-tooltip{position:fixed;max-width:min(400px, 60vw);z-index:9999;background:#111;color:#fff;padding:8px 10px;border-radius:8px;box-shadow:0 4px 14px rgba(0,0,0,0.25);font-size:0.9rem;line-height:1.3}
  .note-tooltip :where(p){margin:0.4em 0}
  .note-tooltip a{color:#9ecbff}
  .note-tooltip .arrow{position:absolute;width:10px;height:10px;background:#111;transform:rotate(45deg)}
  /* Print-friendly adjustments */
@media print {
  /* Page margins */
  @page {
    margin: 12mm;
  }

  /* High-contrast and color handling */
  html, body {
    background: #fff !important;
    color: #000 !important;
    -webkit-print-color-adjust: exact;
    print-color-adjust: exact;
  }

  /* Slightly tighter text to fit more per page */
  :root {
    --font-size: 12px;            /* was 14px */
    --cell-border: 1px solid #000;
    --header-border-thick: 2px solid #000;
    --row-end-border: 1px solid #000;
    --para-end-border: 2px solid #000;
  }

  /* Hide interactive chrome in print */
  header, footer, .controls-row,
  #openBtn, #saveBtn, #resetBtn, #transformBtn,
  #fileInput, #xmlInput, .small-muted.controls,
  .lang-controls, .controls-inline, .viewer .small-muted {
    display: none !important;
  }

  /* Flatten the viewer card */
  .viewer {
    width: auto !important;       /* let it use full page width */
    min-width: 0 !important;
    box-shadow: none !important;
    border: none !important;
    padding: 0 !important;
    background: transparent !important;
  }

  /* Table layout for print (chart only, opt-in via .print-compact class) */
  .chartshell.print-compact {
    width: 100% !important;       /* fit page width */
    border-collapse: collapse !important;
    border-spacing: 0 !important;
  }

  /* Remove colored headers; rely on thicker borders */
  .chartshell.print-compact .row.title1 th,
  .chartshell.print-compact .row.title2 th {
    background: transparent !important;
  }

  /* Solid borders for cells and group rails (chart only) */
  .chartshell.print-compact th, .chartshell.print-compact td {
    border: 1px solid #000 !important;
    padding: 6px 6px !important; /* a bit tighter for paper */
  }
  .chartshell.print-compact th.group-end, .chartshell.print-compact td.group-end {
    border-right: 2px solid #000 !important;
  }
  /* Preserve thicker sentence/paragraph end borders in print */
  .chartshell.print-compact tr.endSent > th, .chartshell.print-compact tr.endSent > td {
    border-bottom: var(--row-end-border) !important;
  }
  .chartshell.print-compact tr.endPara > th, .chartshell.print-compact tr.endPara > td {
    border-bottom: var(--para-end-border) !important;
  }
  .chartshell.print-compact tr > .group-start:first-child {
    border-left: 2px solid #000 !important;
  }

  /* Keep rows together if possible (browser support varies) */
  .chartshell.print-compact tr {
    page-break-inside: avoid;
    break-inside: avoid;
  }

  /* Interlinear: keep gloss readable in grayscale */
  .chartshell.print-compact .interlinear .g {
    color: #333 !important;
  }

  /* Optional: show link targets in print */
  a[href]:after {
    content: " (" attr(href) ")";
    font-size: 0.9em;
  }
  /* Don't print column resize handles */
  .col-resizer { display: none !important; }
  /* Keep abbreviations list together if possible */
  .chart-abbrev-block { break-inside: avoid; page-break-inside: avoid; }
  /* Page breaks for inserted blocks */
  .inserted-html-before-prologue { break-after: page; page-break-after: always; }
  .inserted-html-after-chart { break-before: page; page-break-before: always; }

  /* Replace endnote link markers in notes column with a plain marker for print/PDF */
  .chartshell.endnotes-mode .notes-col .note-link {
    color: #000 !important;
    text-decoration: none !important;
    pointer-events: none !important;
  }
  .chartshell.endnotes-mode .notes-col .note-link sup { display: none !important; }
  .chartshell.endnotes-mode .notes-col .note-link::after {
    content: " *"; /* or " (see notes)" if you prefer */
    font-size: 0.95em;
  }
}
</style>
</head>
<body>

<header>
  <h1>FLExText Discourse Analysis Tool (FDAT) (and FLEx XML Viwer/Exporter)</h1>
  <div style="margin-left:auto" class="small-muted" hidden>© 2025 Seth Johnston</div>
</header>

  <section id="aboutPanel" class="prologue-panel" aria-live="polite" data-collapsed="0" data-no-persist="1" style="background:#eef5ff;border:1px solid #c8dbff;padding:0;border-radius:8px;margin-bottom:12px">
    <div class="collapsible-header" id="aboutHeader" style="padding:10px 14px">
      <span class="small-muted">About FLEx XML Viewer</span>
      <span class="chev">▾</span>
    </div>
    <div class="collapsible-body" style="padding:10px 14px">
  <h2 style="font-size:1rem;margin-top:0">About FLEx XML Viewer</h2>
  <p>
    <strong>FLExText Discourse Analysis Tool (FDAT)</strong> is a client-side web app for viewing and exploring
    <a href="https://software.sil.org/fieldworks/" target="_blank" rel="noopener noreferrer">FieldWorks (FLEx)</a>
    XML exports in a structured, readable format. This app is a part of the <a href="https://github.com/rulingAnts/flet" target="_blank" rel="noopener noreferrer">Field Linguistics Extension Tools collection</a>.
  </p>
  <p style="margin-top:6px"><strong>Privacy</strong>: All conversions happen locally in your browser — your XML and language data never leave your device. There are no uploads or analytics. Preferences (like language order or view options) are stored only in your browser’s local storage. Using “Open in new window” or “Save as HTML” creates a local snapshot you can choose to save or share.</p>
  <p>This viewer supports the following FieldWorks XML export types:</p>
  <ul style="margin-top:4px">
    <li><strong>Discourse Charts</strong> — displays FLEx Text Charts (Discourse Charts) as HTML tables with resizable columns (click and drag column borders in second header row), preserving formatting and interlinear structure.</li>
    <li><strong>Lists</strong> — displays hierarchical <code>&lt;list&gt;</code> structures as collapsible nested lists.</li>
    <li><strong>Translated Lists</strong> — handles multilingual <code>&lt;AUni&gt;</code>-based lists with language ordering and visibility controls.</li>
    <li><strong>Phonology</strong> — renders natural classes, phoneme inventories, and cross-references in human-readable tables.</li>
    <li><strong>Wordforms</strong> — displays lexical items and analyses in expandable cards or sortable tables.</li>
    <li><strong>Generic XML</strong> — provides a recursive tree view for any other well-formed XML data.</li>
  </ul>
  <p>
    This app does <em>not</em> process <strong>LIFT</strong> or <strong>FLExText</strong> exports — those should be opened directly in FLEx. XLingPaper XML exports can open with XLingPpaer. And Word XML files should be opened in Microsoft Word.
  </p>
    </div>
  </section>

<textarea id="xmlInput" placeholder="Paste XML here or choose a file..." hidden></textarea>

<div class="controls-row">
  <button id="transformBtn">Preview</button>
  <button id="resetBtn" class="secondary">Reset</button>

  <label style="display:flex;align-items:center;gap:8px" class="small-muted">
    <input id="showNames" type="checkbox"> Show element names
  </label>

  <label id="repeatHeadersContainer" style="display:none;align-items:center;gap:8px" class="small-muted" title="When printing a Text Chart, repeat the top two header rows at the top of each page">
    <input id="repeatHeaders" type="checkbox"> Repeat chart headers on each printed page
  </label>

  <label id="freezeHeadersContainer" style="display:none;align-items:center;gap:8px" class="small-muted" title="Keep the two chart header rows visible while scrolling">
    <input id="freezeHeaders" type="checkbox"> Freeze chart headers when scrolling
  </label>

  <div style="margin-left:auto;display:flex;gap:8px;align-items:left">
    <input id="fileInput" type="file" accept=".xml,.xml.txt" />
  <button id="exportChartBtn" class="secondary">Export Discourse Chart</button>
    <button id="exportSettingsBtn" class="secondary" title="Export all viewer settings as JSON">Export Settings</button>
    <button id="importSettingsBtn" class="secondary" title="Import viewer settings from JSON">Import Settings</button>
    <input id="settingsImportInput" type="file" accept="application/json,.json" style="display:none" />
  </div>
</div>

<!-- Optional heading and preface (HTML) to insert before a Text Chart -->
<div id="prologuePanel" class="prologue-panel" aria-live="polite" data-collapsed="1">
  <div class="collapsible-header" id="prologueHeader">
    <span class="small-muted">Chart header and note (optional)</span>
    <span class="chev">▸</span>
  </div>
  <div class="collapsible-body">
  <div class="prologue-grid">
    <label for="titleTag">Title element</label>
    <div style="display:flex;gap:8px;align-items:center">
      <select id="titleTag" aria-label="Title element">
        <option value="h1">h1</option>
        <option value="h2">h2</option>
        <option value="h3">h3</option>
        <option value="div">div</option>
        <option value="p">p</option>
      </select>
      <input id="titleText" type="text" placeholder="Enter a chart title (optional)" />
      <button id="clearTitleBtn" class="small-btn secondary" title="Clear title">Clear</button>
    </div>

    <label for="prefaceHtml">Preface (HTML allowed)</label>
    <div class="full">
      <textarea id="prefaceHtml" placeholder="Type any HTML to appear before the chart (optional)"></textarea>
      <div class="small-muted" style="margin-top:6px">
        Tip: You can include basic HTML like <code>&lt;p&gt;</code>, <code>&lt;div&gt;</code>, <code>&lt;em&gt;</code>, or links. 
        If you don't know HTML, leave that to us — when “Auto-convert line breaks” is on, Enter makes a new paragraph and Shift+Enter inserts a line break.
      </div>
      <label class="small-muted" style="display:flex;align-items:center;gap:8px;margin-top:6px">
        <input id="prefaceAuto" type="checkbox" checked> Auto-convert line breaks (Enter = new paragraph, Shift+Enter = line break)
      </label>
    </div>
    <div></div>
    <div style="display:flex;gap:8px">
      <button id="clearPrefaceBtn" class="small-btn secondary" title="Clear preface">Clear preface</button>
    </div>
  </div>
  </div>
</div>

<!-- Abbreviations list (labels + optional definitions) -->
<div id="abbrevPanel" class="abbrev-panel" aria-live="polite" data-collapsed="1">
  <div class="collapsible-header" id="abbrevHeader">
    <span class="small-muted">Abbreviations List (optional)</span>
    <span class="chev">▸</span>
  </div>
  <div class="collapsible-body">
  <div class="abbrev-grid">
    <label for="abbrevInclude">Include list</label>
    <label style="display:flex;align-items:center;gap:8px">
      <input id="abbrevInclude" type="checkbox" checked> Include abbreviations in output
    </label>

    <label for="abbrevPosition">Position</label>
    <div style="display:flex;gap:8px;align-items:center">
      <select id="abbrevPosition">
        <option value="top">Top (below title/preface)</option>
        <option value="bottom">Bottom (after chart)</option>
      </select>
      <button id="abbrevResetFromChart" class="small-btn secondary" title="Re-scan listRef items from chart">Reset from chart</button>
    </div>

    <div class="rows">
  <div class="small-muted" style="margin:6px 0">Each abbreviation is fixed from the chart. Edit a Name and optional Description:</div>
      <div id="abbrevRows"></div>
      <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
        <button id="abbrevAddManual" class="small-btn" title="Add a custom abbreviation">Add abbreviation</button>
        <span class="small-muted">Manual abbreviations are saved and exported with the chart.</span>
      </div>
      <div id="abbrevEmptyMsg" class="small-muted" style="display:none">No listRef items found in this chart.</div>
    </div>
  </div>
  </div>
</div>

<!-- Additional HTML (before Prologue and after Text Chart) -->
<div id="appendHtmlPanel" class="prologue-panel" aria-live="polite" style="display:none" data-collapsed="1">
  <div class="collapsible-header" id="appendHeader">
    <span class="small-muted">Additional HTML Document (optional) - <i>i.e. include your interlinear text with free translations (or include some other description or write-up to bundle with your chart).</i></span>
    <span class="chev">▸</span>
  </div>
  <div class="collapsible-body">
  <div class="prologue-grid">
    <label for="beforeHtmlInput">Before Prologue</label>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <input id="beforeHtmlInput" type="file" accept=".html,.htm,text/html" />
      <button id="clearBeforeHtmlBtn" class="small-btn secondary">Clear</button>
      <span id="beforeHtmlStatus" class="small-muted"></span>
    </div>
    <label for="afterHtmlInput">After Text Chart</label>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <input id="afterHtmlInput" type="file" accept=".html,.htm,text/html" />
      <button id="clearAfterHtmlBtn" class="small-btn secondary">Clear</button>
      <span id="afterHtmlStatus" class="small-muted"></span>
    </div>
    <div class="full small-muted" style="margin-top:6px">
      Tip: The “After Text Chart” HTML will appear before Abbreviations when Abbreviations are placed at the end.
    </div>
  </div>
  <div class="small-muted" style="margin-top:6px">Print: Page breaks are inserted after the Before-Prologue HTML and before the After-Chart HTML.</div>
  </div>
  </div>

  <!-- Salience Bands (row color coding) -->
  <div id="saliencePanel" class="prologue-panel" aria-live="polite" style="display:none" data-collapsed="1">
    <div class="collapsible-header" id="salienceHeader">
      <span class="small-muted">Salience Bands (row color coding)</span>
      <span class="chev">▸</span>
    </div>
    <div class="collapsible-body">
      <div class="small-muted" style="margin-bottom:8px">Create a nested outline of bands. Each band has an automatic number (e.g., 1, 1.1, 1.1.2), a label, and a color. Assign a band to rows from the chart using the “Salience band…” button next to the row number.</div>
      <div class="controls-inline" style="margin:6px 0 10px 0">
        <label class="small-muted" style="display:flex; align-items:center; gap:8px"><input id="salienceEnabled" type="checkbox" checked> Show salience band colors</label>
        <label class="small-muted" style="display:flex; align-items:center; gap:8px"><input id="salienceShowLegend" type="checkbox" checked> Show legend</label>
        <label class="small-muted" style="display:flex; align-items:center; gap:8px"><input id="salienceShowColumn" type="checkbox"> Show salience column</label>
        <label class="small-muted" style="display:flex; align-items:center; gap:8px"><input id="salienceCellOnly" type="checkbox"> Limit color to salience cell only</label>
        <label class="small-muted" title="0 = transparent, 1 = full color" style="display:flex; align-items:center; gap:8px">Opacity <input id="salienceOpacity" type="range" min="0" max="1" step="0.05" value="1" style="width:160px"></label>
      </div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:8px">
        <button id="salAddRoot" class="small-btn">Add band</button>
        <button id="salClearAssignments" class="small-btn secondary" title="Clear band assignments for all rows">Clear all row assignments</button>
      </div>
      <div id="salienceList"></div>
    </div>
  </div>

  <!-- Notes column options -->
  <div id="notesPanel" class="prologue-panel" aria-live="polite" style="display:none" data-collapsed="1">
    <div class="collapsible-header" id="notesHeader">
      <span class="small-muted">Notes column options</span>
      <span class="chev">▸</span>
    </div>
    <div class="collapsible-body">
      <div class="prologue-grid">
        <label for="notesMode">Behavior</label>
        <div>
          <select id="notesMode">
            <option value="inline">Inline (default)</option>
            <option value="hide">Hide notes column</option>
            <option value="endnotes">Convert to endnotes</option>
          </select>
        </div>

        <label for="notesWidth">Width</label>
        <div>
          <input id="notesWidth" type="text" placeholder="e.g., 24ch, 280px, 20%, 2in, 5cm" />
          <div class="small-muted" style="margin-top:6px">Leave blank for default. Units supported by CSS are accepted.</div>
        </div>
        <div></div>
        <div style="display:flex;gap:8px">
          <button id="notesReset" class="small-btn secondary">Reset</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Free translations options -->
  <div id="ftPanel" class="prologue-panel" aria-live="polite" style="display:none" data-collapsed="1">
    <div class="collapsible-header" id="ftHeader">
      <span class="small-muted">Free translations</span>
      <span class="chev">▸</span>
    </div>
    <div class="collapsible-body">
      <div class="prologue-grid">
        <label for="ftMode">Display</label>
        <div>
          <select id="ftMode">
            <option value="tooltip">Tooltip + links (exported)</option>
            <option value="inline">Inline under each row</option>
          </select>
          <div class="small-muted" style="margin-top:6px">Add/edit with the “Add Trans…” button next to row numbers in the preview. Buttons are not included in Export.</div>
        </div>
        <label>Inline style (when mode = Inline)</label>
        <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap">
          <label class="small-muted" title="Text size in CSS units (e.g., 0.95rem, 14px)">Font size <input id="ftFontSize" type="text" placeholder="e.g., 0.95rem or 14px" style="width:140px; padding:6px; border:1px solid #e5e5e5; border-radius:6px"></label>
          <label class="small-muted">Text color <input id="ftColor" type="color" value="#333333"></label>
          <label class="small-muted">Row background <input id="ftBg" type="color" value="#fbfcff"></label>
        </div>
        <div></div>
        <div style="display:flex; gap:8px">
          <button id="ftClearAll" class="small-btn secondary">Clear all translations</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Epilogue (HTML/Text after everything in export) -->
  <div id="postloguePanel" class="prologue-panel" aria-live="polite" style="display:none" data-collapsed="1">
    <div class="collapsible-header" id="postlogueHeader">
      <span class="small-muted">Epilogue (optional) — text or HTML to append at the very end</span>
      <span class="chev">▸</span>
    </div>
    <div class="collapsible-body">
      <div class="prologue-grid">
        <label for="postlogueHtml">Epilogue</label>
        <div class="full">
          <textarea id="postlogueHtml" placeholder="Type text or HTML to appear at the very end (optional)"></textarea>
          <label class="small-muted" style="display:flex;align-items:center;gap:8px;margin-top:6px">
            <input id="postlogueAuto" type="checkbox" checked> Auto-convert line breaks (Enter = new paragraph, Shift+Enter = line break)
          </label>
        </div>
      </div>
    </div>
    </div>

  <!-- ListRef Styling/Ordering -->
<div id="listRefPanel" class="listref-panel" aria-live="polite" style="display:none" data-collapsed="1">
  <div class="collapsible-header" id="listRefHeader">
    <span class="small-muted">Text Chart Marker Display and Order Settings</span>
    <span class="chev">▸</span>
  </div>
  <div class="collapsible-body">
  <div class="listref-grid">
    <div class="rows">
      <div class="small-muted" style="margin:6px 0; display:flex; align-items:center; gap:12px; justify-content:space-between; flex-wrap:wrap">
        <span>Control how specific TextChart Markers render in cells. Order here sets left-to-right order within the same cell. Styling and visibility only affect in-cell TextChart Markers; the Abbreviations list remains alphabetical.</span>
        <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap">
          <label title="Choose how to order tokens in cells">
            <select id="listRefEnforceMode">
              <option value="none" selected>No ordering (source order)</option>
              <option value="groups">Enforce within groups</option>
              <option value="global">Enforce globally</option>
            </select>
          </label>
          <button id="listRefToggleOrder" class="small-btn secondary" title="Toggle ordering direction">(top → bottom)</button>
          <button id="listRefShowAll" class="small-btn" title="Show all abbreviations">Show all</button>
          <button id="listRefHideAll" class="small-btn secondary" title="Hide all abbreviations">Hide all</button>
          <button id="listRefResetAllStyles" class="small-btn secondary" title="Clear styles for all groups and items (keep visibility/order)">Reset all styles</button>
          <button id="listRefResetOrder" class="small-btn secondary" title="Reset order to most prevalent pattern from this chart">Reset order</button>
        </div>
      </div>
      <div id="listRefGroups"></div>
      <div id="listRefRows"></div>
      <div id="listRefWarnings" class="small-muted" style="margin-top:8px; display:none"></div>
      <div style="margin-top:8px">
        <div class="small-muted" style="font-weight:600;margin-bottom:6px">Groups</div>
        <div id="listRefGroupList"></div>
        <div style="margin-top:6px;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <input id="listRefNewGroupName" type="text" placeholder="New group name" style="padding:6px;border:1px solid #e5e5e5;border-radius:6px">
          <button id="listRefAddGroup" class="small-btn">Add group</button>
        </div>
      </div>
    </div>
  </div>
  </div>
</div>

<div id="viewer" class="viewer" aria-live="polite">
  <div class="viewer-header" style="font-weight:600;margin-bottom:8px">Preview</div>
  <div id="renderArea" class="small-muted">Paste or upload an XML file, then click Preview.</div>
</div>

<footer>
  <div>© 2025 Seth Johnston. This software is licensed under the <a href="https://www.gnu.org/licenses/agpl-3.0.html" target="_blank" rel="noopener noreferrer">GNU Affero General Public License v3.0 (AGPL-3.0)</a>.</div>
  <div>The vast majority of this code was generated collaboratively with <strong>ChatGPT (GPT-5)</strong> by OpenAI, under the author’s direction and guidance.</div>
  <div>Download the latest Installer or Portable App <a href="https://github.com/rulingAnts/flexml_display/releases/latest" target="_blank" rel="noopener noreferrer">here</a>.</div>
</footer>

<script>
/* ===== Helpers ===== */
const byId = id => document.getElementById(id);
const escapeHtml = s => String(s||'').replace(/[&<>"]/g, c=>'&' + ({'&':'amp','<':'lt','>':'gt','"':'quot'})[c] + ';');
function create(tag, attrs={}, text){
  const el = document.createElement(tag);
  for(const k in attrs){
    if(k==='cls') el.className = attrs[k];
    else el.setAttribute(k, attrs[k]);
  }
  if(text !== undefined && text !== null) el.textContent = text;
  return el;
}

/* ===== Persistence keys and state ===== */
const LANG_PREFS_KEY = 'flex_xml_viewer_lang_prefs_v1';
const WORDFORM_PREFS_KEY = 'flex_xml_viewer_wordform_prefs_v1';
const TEXTCHART_PROLOGUE_KEY = 'flex_textchart_prologue_v1';
const TEXTCHART_POSTLOGUE_KEY = 'flex_textchart_postlogue_v1';
const PRINT_HEADERS_KEY = 'flex_textchart_repeat_headers_v1';
const FREEZE_HEADERS_KEY = 'flex_textchart_freeze_headers_v1';
const ABBREV_PREFS_KEY = 'flex_textchart_abbrevs_v1';
const LISTREF_PREFS_KEY = 'flex_textchart_listrefs_v2';
const FT_PREFS_KEY = 'flex_textchart_free_trans_prefs_v1';
const SALIENCE_PREFS_KEY = 'flex_textchart_salience_bands_v1';
const ROW_GUIDS_KEY = 'flex_textchart_row_guids_v1';
const TOKEN_GUIDS_KEY = 'flex_textchart_token_guids_v1';
const NOTE_GUIDS_KEY = 'flex_textchart_note_guids_v1';

// GUID utilities
function newGuid(){
  // RFC4122-ish random GUID (not cryptographically strong, sufficient for client persistence)
  const s = () => Math.floor((1+Math.random())*0x10000).toString(16).slice(1);
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c=>{
    const r = Math.random()*16|0, v = c==='x'? r : (r&0x3|0x8); return v.toString(16);
  });
}
function loadRowGuidMap(){ return loadJSON(ROW_GUIDS_KEY) || { byIdx:{}, byLabel:{} }; }
function saveRowGuidMap(map){ saveJSON(ROW_GUIDS_KEY, map); }
function getOrAssignRowGuid(tr){
  try{
    const idxAttr = tr.getAttribute('data-row-idx');
    const label = computeRowLabelFromRow(tr);
    const map = loadRowGuidMap();
    const idx = idxAttr ? String(idxAttr) : '';
    let guid = '';
    // Prefer existing mapping by idx; fallback to label if present
    if(idx && map.byIdx[idx]) guid = map.byIdx[idx];
    else if(label && map.byLabel[label]) guid = map.byLabel[label];
    if(!guid){ guid = newGuid(); }
    // Update both indices for robustness over time
    if(idx) map.byIdx[idx] = guid;
    if(label) map.byLabel[label] = guid;
    saveRowGuidMap(map);
    // Reflect on DOM for faster access
    tr.setAttribute('data-row-guid', guid);
    return guid;
  }catch(_){ return ''; }
}
function getRowGuidFromTr(tr){ return tr.getAttribute('data-row-guid') || getOrAssignRowGuid(tr); }
function getRowGuidByLabel(label){ const map = loadRowGuidMap(); return (map.byLabel||{})[label] || ''; }
function getRowGuidByIndex(idx){ const map = loadRowGuidMap(); return (map.byIdx||{})[String(idx)] || ''; }

// Token GUID registry: key shape `${rowIdx}:${kind}:${pos}` → guid
function loadTokenGuidMap(){ return loadJSON(TOKEN_GUIDS_KEY) || { byKey:{} }; }
function saveTokenGuidMap(map){ saveJSON(TOKEN_GUIDS_KEY, map); }
function tokenKindFromPair(pair){
  const cls = pair.className || '';
  if(/\blistRef\b/.test(cls)) return 'listRef';
  if(/\bclauseMkr\b/.test(cls)) return 'clauseMkr';
  if(/\brownum\b/.test(cls)) return 'rownum';
  if(/\bnote\b/.test(cls)) return 'note';
  if(/\bpunct-open\b/.test(cls)) return 'punctOpen';
  if(/\bpunct-close\b/.test(cls)) return 'punctClose';
  return 'token';
}
function assignTokenGuids(area){
  const tbl = area?.querySelector('table.chartshell'); if(!tbl) return;
  const map = loadTokenGuidMap(); const byKey = map.byKey || {}; let updated = false;
  const rows = Array.from(tbl.querySelectorAll('tbody tr')).filter(r=> !r.classList.contains('title1') && !r.classList.contains('title2') && !r.classList.contains('ft-inline'));
  rows.forEach(r=>{
    const rowIdx = r.getAttribute('data-row-idx') || '';
    // Walk tokens in row order
    const pairs = Array.from(r.querySelectorAll('.interlinear .pair'));
    pairs.forEach((pair, i)=>{
      const kind = tokenKindFromPair(pair);
      const key = `${rowIdx}:${kind}:${i+1}`;
      let guid = byKey[key];
      if(!guid){ guid = newGuid(); byKey[key] = guid; updated = true; }
      pair.setAttribute('data-token-guid', guid);
      pair.setAttribute('data-token-key', key);
    });
  });
  if(updated){ saveTokenGuidMap({ byKey }); }
}

// Note GUID registry: byRowGuid → noteGuid (for endnotes mode)
function loadNoteGuidMap(){ return loadJSON(NOTE_GUIDS_KEY) || { byRowGuid:{} }; }
function saveNoteGuidMap(map){ saveJSON(NOTE_GUIDS_KEY, map); }
function assignNoteGuids(area){
  const tbl = area?.querySelector('table.chartshell'); if(!tbl) return;
  const noteLinks = Array.from(tbl.querySelectorAll('a.note-link'));
  if(!noteLinks.length) return; // only in endnotes mode
  const map = loadNoteGuidMap(); const byRowGuid = map.byRowGuid || {}; let updated = false;
  noteLinks.forEach(a=>{
    const tr = a.closest('tr'); if(!tr) return;
    const rowGuid = getOrAssignRowGuid(tr); if(!rowGuid) return;
    let ng = byRowGuid[rowGuid]; if(!ng){ ng = newGuid(); byRowGuid[rowGuid] = ng; updated = true; }
    a.setAttribute('data-note-guid', ng);
    const href = a.getAttribute('href') || '';
    if(href.startsWith('#')){
      const id = href.slice(1);
      const endnote = document.getElementById(id);
      if(endnote) endnote.setAttribute('data-note-guid', ng);
    }
  });
  if(updated){ saveNoteGuidMap({ byRowGuid }); }
}

// { mode: 'tooltip'|'inline', items: { [rowLabel:string]: string }, style: { fontSize?:string, color?:string, bg?:string } }
function loadFTPrefs(){ const d = loadJSON(FT_PREFS_KEY) || {}; return { mode: d.mode || 'tooltip', items: d.items || {}, style: d.style || {} }; }
function saveFTPrefs(p){ saveJSON(FT_PREFS_KEY, p); }

let globalState = {
  phonemeIndex: {},
  idToNatclassIds: {},
  natclassElements: {},
  phonemeRowIds: {},
  showNames: false,
  chartAbbrevLabels: [],
  listRefLabels: [],
  listRefPrefs: null,
  abbrevPrefs: null,
  beforeHtml: null,
  beforeHtmlName: '',
  afterHtml: null,
  afterHtmlName: '',
  postlogueHtml: '',
  postlogueAuto: true
};

function saveJSON(key, obj){ try{ localStorage.setItem(key, JSON.stringify(obj)); } catch(e){} }
function loadJSON(key){ try{ const s = localStorage.getItem(key); return s ? JSON.parse(s) : null; } catch(e){ return null; } }

/* ===== File & UI wiring ===== */
byId('fileInput').addEventListener('change', async e=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const text = await f.text();
  byId('xmlInput').value = text;
});

byId('resetBtn').addEventListener('click', ()=>{
  byId('xmlInput').value = '';
  byId('renderArea').innerHTML = '<div class="small-muted">Paste or upload an XML file, then click Preview.</div>';
  // Hide optional chart prologue controls when no chart is displayed
  showProloguePanel(false);
});

byId('transformBtn').addEventListener('click', async ()=> {
  const xmlText = byId('xmlInput').value.trim();
  if(!xmlText){ alert('Please paste or upload an XML document first.'); return; }
  try {
    const p = new DOMParser();
    const xmlDoc = p.parseFromString(xmlText, 'application/xml');
    if(xmlDoc.querySelector('parsererror')) throw new Error('XML parse error');
    // Collapse About panel on preview (non-persistent when data-no-persist=1)
    const aboutPanel = byId('aboutPanel'); const aboutHeader = byId('aboutHeader');
    if(aboutPanel && aboutHeader && aboutPanel.getAttribute('data-collapsed') !== '1'){
      aboutPanel.setAttribute('data-collapsed','1');
      const chev = aboutHeader.querySelector('.chev'); if(chev) chev.textContent = '▸';
      aboutHeader.setAttribute('aria-expanded','false');
      if(aboutPanel.getAttribute('data-no-persist') !== '1'){
        const state = loadCollapseState(); state['aboutPanel'] = true; saveCollapseState(state);
      }
    }
    await renderDocument(xmlDoc);
  } catch(err){
    alert('Error parsing XML: ' + err.message);
  }
});

// Export Discourse Chart: open exported chart in a new window with toolbar
byId('exportChartBtn').addEventListener('click', ()=>{
  const html = buildStandaloneHTML({ includeToolbar: true });
  const w = window.open('', '_blank');
  if(!w) return;
  w.document.write(html);
  w.document.close();
});

function sanitizeFilename(name){
  // Remove illegal characters for Windows/macOS, collapse spaces, and trim
  return (name || 'export')
    .replace(/[\\/:*?"<>|]+/g, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .slice(0, 120);
}
function getExportTitleFromPrologue(){
  let exportTitle = 'FLEx XML View Export';
  const render = byId('renderArea');
  if(!render) return exportTitle;
  const prologueNode = render.querySelector(':scope > .chart-prologue');
  if (prologueNode) {
    const h1 = prologueNode.querySelector('h1');
    const anyHead = prologueNode.querySelector('h1,h2,h3,h4,h5,h6,div,p');
    const titleNode = h1 || anyHead;
    if (titleNode && titleNode.textContent) {
      const t = titleNode.textContent.replace(/\s+/g, ' ').trim();
      if (t) exportTitle = t;
    }
  }
  return exportTitle;
}
function suggestExportFilename(){
  const baseTitle = getExportTitleFromPrologue();
  const hasChart = !!byId('renderArea')?.querySelector('table.chartshell');
  const withContext = hasChart ? `${baseTitle} — Text Chart` : baseTitle;
  let name = sanitizeFilename(withContext || 'FLEx XML View Export');
  if(!/\.html?$/i.test(name)) name += '.html';
  return name;
}

// Export / Import Settings (localStorage backup)
function collectAllSettings(){
  const keys = [
    LANG_PREFS_KEY,
    WORDFORM_PREFS_KEY,
    TEXTCHART_PROLOGUE_KEY,
    TEXTCHART_POSTLOGUE_KEY,
    PRINT_HEADERS_KEY,
    FREEZE_HEADERS_KEY,
    ABBREV_PREFS_KEY,
    LISTREF_PREFS_KEY,
    FT_PREFS_KEY,
    SALIENCE_PREFS_KEY,
    ROW_GUIDS_KEY,
    TOKEN_GUIDS_KEY,
    NOTE_GUIDS_KEY,
    COLLAPSE_STATE_KEY
  ];
  const out = {};
  keys.forEach(k=>{ try{ const v = localStorage.getItem(k); if(v !== null) out[k] = JSON.parse(v); } catch(_){ /* ignore parse errors */ } });
  return out;
}
function importAllSettings(obj){
  if(!obj || typeof obj !== 'object') throw new Error('Invalid settings file');
  Object.keys(obj).forEach(k=>{ try{ localStorage.setItem(k, JSON.stringify(obj[k])); } catch(_){ /* ignore */ } });
}
function downloadJSON(filename, data){
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click(); URL.revokeObjectURL(a.href);
}
const exportBtn = byId('exportSettingsBtn');
const importBtn = byId('importSettingsBtn');
const importInput = byId('settingsImportInput');
if(exportBtn){ exportBtn.addEventListener('click', ()=>{
  const data = collectAllSettings();
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  downloadJSON(`flexxml-viewer-settings-${ts}.json`, { __meta:{ app:'flexxml-viewer', version:1, exportedAt: new Date().toISOString() }, data });
}); }
if(importBtn && importInput){
  importBtn.addEventListener('click', ()=> importInput.click());
  importInput.addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0]; if(!f) return;
    try{
      const txt = await f.text();
      const json = JSON.parse(txt);
      const payload = json && (json.data || json);
      importAllSettings(payload);
      alert('Settings imported. Reloading to apply…');
      location.reload();
    }catch(err){ alert('Failed to import settings: ' + (err?.message || String(err))); }
  });
}

byId('showNames').addEventListener('change', e=>{
  globalState.showNames = e.target.checked;
  document.querySelectorAll('[data-gen-label]').forEach(el=>{
    const label = el.getAttribute('data-gen-label');
    const prev = el.previousSibling;
    if(prev) prev.textContent = globalState.showNames ? (label + ': ') : '';
  });
});

/* ===== Print header repetition (Text Chart only) ===== */
function setPrintHeadersEnabled(enabled){
  const STYLE_ID = 'textchart-print-headers-style';
  let el = document.getElementById(STYLE_ID);
  if(enabled){
    // With thead emitted by XSL, most browsers repeat header automatically. Add guard CSS for reliability.
    const css = `@media print {\n  thead { display: table-header-group !important; }\n}`;
    if(!el){ el = document.createElement('style'); el.id = STYLE_ID; document.head.appendChild(el); }
    el.textContent = css;
  } else {
    if(el) el.remove();
  }
}
function initRepeatHeadersControl(){
  const box = byId('repeatHeaders');
  const container = byId('repeatHeadersContainer');
  if(!box || !container) return;
  const saved = loadJSON(PRINT_HEADERS_KEY);
  const enabled = !!(saved && saved.enabled);
  box.checked = enabled;
  setPrintHeadersEnabled(enabled);
  box.addEventListener('change', ()=>{
    const val = !!box.checked;
    setPrintHeadersEnabled(val);
    saveJSON(PRINT_HEADERS_KEY, { enabled: val });
  });
}
// Initialize once
initRepeatHeadersControl();

/* ===== Freeze headers (sticky title rows) ===== */
function setFreezeHeadersEnabled(enabled){
  const area = byId('renderArea');
  const tbl = area?.querySelector('table.chartshell');
  if(!tbl) return;
  const wrapper = tbl.closest('.chartshell-wrapper') || tbl.parentElement;
  if(enabled){
    tbl.classList.add('freeze-headers');
    // Ensure we have a spacer element right before the table to offset layout when headers stick
    let spacer = wrapper?.querySelector(':scope > .chartshell-sticky-spacer');
    if(!spacer){
      spacer = document.createElement('div');
      spacer.className = 'chartshell-sticky-spacer';
      if(wrapper) wrapper.insertBefore(spacer, tbl);
      else tbl.parentElement?.insertBefore(spacer, tbl);
    }
    computeStickyOffsets();
  } else {
    tbl.classList.remove('freeze-headers');
    const spacer = wrapper?.querySelector(':scope > .chartshell-sticky-spacer');
    if(spacer) spacer.remove();
    document.documentElement.style.removeProperty('--tc-sticky-top-1');
    document.documentElement.style.removeProperty('--tc-sticky-top-2');
    document.documentElement.style.removeProperty('--tc-sticky-spacer');
  }
}
function computeStickyOffsets(){
  const area = byId('renderArea');
  const tbl = area?.querySelector('table.chartshell');
  if(!tbl) return;
  const head = tbl.querySelector('thead');
  const r1 = head?.querySelector('tr.row.title1');
  const r2 = head?.querySelector('tr.row.title2');
  const rect1 = r1?.getBoundingClientRect();
  const rect2 = r2?.getBoundingClientRect();
  // Account for any fixed UI at the top (none by default). We can also consider header height.
  const topBase = 0;
  const h1 = rect1 ? Math.ceil(rect1.height) : 0;
  const h2 = rect2 ? Math.ceil(rect2.height) : 0;
  document.documentElement.style.setProperty('--tc-sticky-top-1', topBase + 'px');
  document.documentElement.style.setProperty('--tc-sticky-top-2', (topBase + h1) + 'px');
  document.documentElement.style.setProperty('--tc-sticky-spacer', (h1 + h2) + 'px');
}
function initFreezeHeadersControl(){
  const box = byId('freezeHeaders');
  const container = byId('freezeHeadersContainer');
  if(!box || !container) return;
  const saved = loadJSON(FREEZE_HEADERS_KEY);
  const enabled = !!(saved && saved.enabled);
  box.checked = enabled;
  // Only apply after a chart is rendered; this function may run before the table exists
  box.addEventListener('change', ()=>{
    const val = !!box.checked; saveJSON(FREEZE_HEADERS_KEY, { enabled: val }); setFreezeHeadersEnabled(val);
  });
}

/* ===== Collapsible panels (Text Chart settings) ===== */
const COLLAPSE_STATE_KEY = 'flex_textchart_collapse_state_v1';
function loadCollapseState(){ return loadJSON(COLLAPSE_STATE_KEY) || {}; }
function saveCollapseState(s){ saveJSON(COLLAPSE_STATE_KEY, s); }
function wireCollapsible(panelId, headerId){
  const panel = byId(panelId); const header = byId(headerId);
  if(!panel || !header) return;
  let state = loadCollapseState();
  const key = panelId;
  const noPersist = panel.getAttribute('data-no-persist') === '1';
  // default collapsed is taken from data-collapsed attribute if present; else default to true
  const defaultCollapsed = panel.hasAttribute('data-collapsed') ? (panel.getAttribute('data-collapsed') === '1') : true;
  const collapsed = noPersist ? defaultCollapsed : (state[key] !== undefined ? !!state[key] : defaultCollapsed);
  panel.setAttribute('data-collapsed', collapsed ? '1' : '0');
  const chev = header.querySelector('.chev'); if(chev) chev.textContent = collapsed ? '▸' : '▾';
  header.setAttribute('role','button'); header.setAttribute('tabindex','0'); header.setAttribute('aria-expanded', (!collapsed).toString());
  function toggle(){
    const isCollapsed = panel.getAttribute('data-collapsed') === '1';
    panel.setAttribute('data-collapsed', isCollapsed ? '0' : '1');
    if(chev) chev.textContent = isCollapsed ? '▾' : '▸';
    header.setAttribute('aria-expanded', isCollapsed ? 'true' : 'false');
    if(!noPersist){ state = loadCollapseState(); state[key] = !isCollapsed; saveCollapseState(state); }
  }
  header.addEventListener('click', toggle);
  header.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); toggle(); } });
}

/* ===== Prologue (title + preface HTML) controls wiring ===== */
function loadProloguePrefs(){
  const d = loadJSON(TEXTCHART_PROLOGUE_KEY) || {};
  return {
    tag: d.tag || 'h1',
    titleText: d.titleText || '',
    prefaceHtml: d.prefaceHtml || '', // stores raw user text or HTML
    autoConvert: typeof d.autoConvert === 'boolean' ? d.autoConvert : true
  };
}
function saveProloguePrefs(p){ saveJSON(TEXTCHART_PROLOGUE_KEY, p); }
function initPrologueControls(){
  const panel = byId('prologuePanel');
  const tagSel = byId('titleTag');
  const titleIn = byId('titleText');
  const preTA = byId('prefaceHtml');
  const preAuto = byId('prefaceAuto');
  const clearTitleBtn = byId('clearTitleBtn');
  const clearPrefaceBtn = byId('clearPrefaceBtn');
  if(!panel || !tagSel || !titleIn || !preTA) return;
  const prefs = loadProloguePrefs();
  tagSel.value = prefs.tag || 'h1';
  titleIn.value = prefs.titleText || '';
  preTA.value = prefs.prefaceHtml || '';
  if(preAuto) preAuto.checked = !!prefs.autoConvert;
  const onChange = ()=>{
    const p = { tag: tagSel.value, titleText: titleIn.value, prefaceHtml: preTA.value, autoConvert: !!(preAuto && preAuto.checked) };
    saveProloguePrefs(p);
    // Live-update DOM if a text chart is displayed
    applyPrologueToRenderArea(p);
  };
  tagSel.addEventListener('change', onChange);
  titleIn.addEventListener('input', onChange);
  preTA.addEventListener('input', onChange);
  preAuto?.addEventListener('change', onChange);
  clearTitleBtn?.addEventListener('click', ()=>{ titleIn.value=''; onChange(); });
  clearPrefaceBtn?.addEventListener('click', ()=>{ preTA.value=''; onChange(); });

  // Map Enter to paragraph and Shift+Enter to single line break within the textarea
  preTA.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){
      e.preventDefault();
      const isShift = e.shiftKey;
      const val = preTA.value;
      const start = preTA.selectionStart;
      const end = preTA.selectionEnd;
      const insertText = isShift ? '\n' : '\n\n';
      preTA.value = val.slice(0, start) + insertText + val.slice(end);
      const newPos = start + insertText.length;
      preTA.selectionStart = preTA.selectionEnd = newPos;
      onChange();
    }
  });
}
// Ensure controls are initialized on load
initPrologueControls();
function showProloguePanel(show){ byId('prologuePanel').style.display = show ? 'block' : 'none'; }

// Wire About panel collapsible on load
wireCollapsible('aboutPanel','aboutHeader');

/* ===== Postlogue controls (stored and used only for export) ===== */
function loadPostloguePrefs(){
  const d = loadJSON(TEXTCHART_POSTLOGUE_KEY) || {};
  return {
    html: d.html || '',
    autoConvert: typeof d.autoConvert === 'boolean' ? d.autoConvert : true
  };
}
function savePostloguePrefs(p){ saveJSON(TEXTCHART_POSTLOGUE_KEY, p); }
function initPostlogueControls(){
  const panel = byId('postloguePanel'); if(!panel) return;
  const ta = byId('postlogueHtml');
  const auto = byId('postlogueAuto');
  const prefs = loadPostloguePrefs();
  if(ta) ta.value = prefs.html || '';
  if(auto) auto.checked = !!prefs.autoConvert;
  const onChange = ()=>{
    const p = { html: ta?.value || '', autoConvert: !!(auto && auto.checked) };
    savePostloguePrefs(p);
    globalState.postlogueHtml = p.html; globalState.postlogueAuto = p.autoConvert;
    applyEpilogueToRenderArea(p);
  };
  ta?.addEventListener('input', onChange);
  auto?.addEventListener('change', onChange);
  // keyboard conveniences similar to prologue
  ta?.addEventListener('keydown', (e)=>{
    if(e.key==='Enter'){
      e.preventDefault();
      const isShift = e.shiftKey; const val = ta.value; const start = ta.selectionStart; const end = ta.selectionEnd;
      const insertText = isShift ? '\n' : '\n\n';
      ta.value = val.slice(0,start) + insertText + val.slice(end);
      const newPos = start + insertText.length; ta.selectionStart = ta.selectionEnd = newPos; onChange();
    }
  });
}
function showPostloguePanel(show){ const p = byId('postloguePanel'); if(p) p.style.display = show ? 'block' : 'none'; }

function applyEpilogueToRenderArea(prefs){
  const area = byId('renderArea'); if(!area) return;
  // Remove existing epilogue block
  area.querySelectorAll(':scope > .chart-epilogue').forEach(n=> n.remove());
  const { html, autoConvert } = (prefs || loadPostloguePrefs());
  let content = html || '';
  if(!content || !content.trim()) return;
  const appearsHtml = /<\s*[a-zA-Z!/]/.test(content);
  if(autoConvert && !appearsHtml){
    const norm = content.replace(/\r\n?/g, '\n');
    const paras = norm.split(/\n{2,}/).map(s=> s.trim()).filter(Boolean);
    content = paras.map(p => `<p>${escapeHtml(p).replace(/\n/g, '<br />')}</p>`).join('\n');
  }
  const block = document.createElement('div'); block.className = 'chart-epilogue';
  const wrapper = document.createElement('div'); wrapper.innerHTML = content;
  Array.from(wrapper.childNodes).forEach(n => block.appendChild(n));
  // Insert epilogue at the very end of render area
  area.appendChild(block);
}
/* ===== ListRef (hide/style/order) controls ===== */
function collectListRefLabelsFromRendered(area){
  const nodes = Array.from(area.querySelectorAll('.interlinear .pair.listRef[data-listref]'));
  const set = new Set();
  nodes.forEach(n=>{ const v=(n.getAttribute('data-listref')||'').trim(); if(v && !set.has(v)) set.add(v); });
  // Preserve first-encounter order; do not alphabetize
  return Array.from(set);
}
// Derive a suggested global order based on most common contiguous listRef patterns in the source XML
function computeListRefSuggestedOrderFromXml(xmlDoc){
  try{
    const runs = [];
    const mains = Array.from(xmlDoc.querySelectorAll('chart > row > cell > main'));
    mains.forEach(m => {
      const kids = Array.from(m.children || []);
      let i = 0;
      while(i < kids.length){
        if(kids[i].nodeName === 'listRef' || kids[i].nodeName === 'listref'){
          const run = [];
          let j = i;
          while(j < kids.length && (kids[j].nodeName === 'listRef' || kids[j].nodeName === 'listref')){
            const label = (kids[j].textContent || '').trim();
            if(label) run.push(label);
            j++;
          }
          if(run.length > 1) runs.push(run);
          i = j;
        } else {
          i++;
        }
      }
    });
  const labelsSet = new Set();
  const firstSeen = {};
  runs.forEach(r => r.forEach(l => { if(!labelsSet.has(l)){ firstSeen[l] = Object.keys(firstSeen).length; labelsSet.add(l); } }));
  const labels = Array.from(labelsSet);
    if(labels.length === 0) return [];
    // Pairwise precedence counts
    const wins = {}; const losses = {};
    labels.forEach(l => { wins[l] = {}; losses[l] = {}; labels.forEach(o => { wins[l][o] = 0; losses[l][o] = 0; }); });
    runs.forEach(run => {
      for(let a=0; a<run.length; a++){
        for(let b=a+1; b<run.length; b++){
          const x = run[a], y = run[b];
          if(x === y) continue;
          wins[x][y] = (wins[x][y]||0) + 1;
          losses[y][x] = (losses[y][x]||0) + 1;
        }
      }
    });
    const score = l => {
      let w = 0, d = 0;
      Object.keys(wins[l]||{}).forEach(k => { w += wins[l][k]||0; d += losses[l][k]||0; });
      return w - d;
    };
    const suggested = labels.sort((a,b)=>{
      const sa = score(a), sb = score(b);
      if(sb !== sa) return sb - sa; // higher score first (earlier)
      // Tie-breaker: first-seen order in XML, not alphabetical
      return (firstSeen[a]||0) - (firstSeen[b]||0);
    });
    return suggested;
  }catch(_){ return []; }
}
function loadListRefPrefs(){
  const d = loadJSON(LISTREF_PREFS_KEY) || {};
  return {
    entries: d.entries || {},
    order: Array.isArray(d.order) ? d.order : [],
    enforce: typeof d.enforce === 'boolean' ? d.enforce : undefined,
    enforceMode: d.enforceMode || (typeof d.enforce === 'boolean' ? (d.enforce ? 'global' : 'none') : 'global'),
    reverse: !!d.reverse,
    groups: Array.isArray(d.groups) ? d.groups : [] // [{id,name,order:[], styles:{hidden,bold,italic,underline,fontSize,color}}]
  };
}
function saveListRefPrefs(p){ saveJSON(LISTREF_PREFS_KEY, p); }
function reconcileListRefPrefs(prefs, labels, suggestedOrder){
  const out = { entries: { ...prefs.entries }, order: Array.from(prefs.order||[]), enforceMode: ['none','groups','global'].includes(prefs.enforceMode) ? prefs.enforceMode : 'global', reverse: !!prefs.reverse, groups: Array.isArray(prefs.groups) ? prefs.groups.map(g=>({...g})) : [] };
  // Remove stale entries
  Object.keys(out.entries).forEach(k=>{ if(!labels.includes(k)) delete out.entries[k]; });
  // Helper: normalize an entry so unset values are truly undefined
  function normalizeEntry(e){ if(!e) return e; ['hidden','bold','italic','underline'].forEach(k=>{ if(e[k] === false) delete e[k]; }); if(e.fontSize === '') delete e.fontSize; if(e.color === '') delete e.color; return e; }
  Object.keys(out.entries).forEach(k=>{ out.entries[k] = normalizeEntry(out.entries[k]); });
  // Add new labels with defaults
  labels.forEach(l=>{ if(!out.entries[l]) out.entries[l] = {}; });
  // Determine base order: prefer saved order; else suggested; else alphabetical
  let base = out.order && out.order.length ? out.order.slice() : (Array.isArray(suggestedOrder) && suggestedOrder.length ? suggestedOrder.slice() : labels.slice());
  // Compact to labels set and append any missing labels
  const ordered = base.filter(x => labels.includes(x));
  labels.forEach(l=>{ if(!ordered.includes(l)) ordered.push(l); });
  out.order = ordered;
  // Remove group members that no longer exist
  out.groups.forEach(g=>{ if(Array.isArray(g.order)) g.order = g.order.filter(x=> labels.includes(x)); });
  return out;
}
function showListRefPanel(show){ const p = byId('listRefPanel'); if(p) p.style.display = show ? 'block':'none'; }
function buildListRefControls(labels, suggestedOrder){
  const panel = byId('listRefPanel'); if(!panel) return;
  const rowsHost = byId('listRefRows');
  const groupsHost = byId('listRefGroupList');
  const resetBtn = byId('listRefResetOrder');
  const enforceSel = byId('listRefEnforceMode');
  const dirBtn = byId('listRefToggleOrder');
  const showAllBtn = byId('listRefShowAll');
  const hideAllBtn = byId('listRefHideAll');
  const resetAllStylesBtn = byId('listRefResetAllStyles');
  const addGroupBtn = byId('listRefAddGroup');
  const newGroupNameIn = byId('listRefNewGroupName');
  let prefs = reconcileListRefPrefs(loadListRefPrefs(), labels, suggestedOrder||[]);
  globalState.listRefPrefs = prefs; saveListRefPrefs(prefs);
  if(enforceSel){ enforceSel.value = prefs.enforceMode || 'global'; enforceSel.addEventListener('change', ()=>{ prefs.enforceMode = enforceSel.value; persist(); applyListRefPrefsToArea(); }); }
  function updateDirButton(){ if(dirBtn) dirBtn.textContent = prefs.reverse ? '(bottom → top)' : '(top → bottom)'; }
  if(dirBtn){ dirBtn.addEventListener('click', ()=>{ prefs.reverse = !prefs.reverse; persist(); applyListRefPrefsToArea(); updateDirButton(); }); }
  updateDirButton();
  if(showAllBtn){ showAllBtn.addEventListener('click', ()=>{ Object.values(prefs.entries).forEach(e=> e.hidden=false); persist(); applyListRefPrefsToArea(); renderRows(); }); }
  if(hideAllBtn){ hideAllBtn.addEventListener('click', ()=>{ Object.values(prefs.entries).forEach(e=> e.hidden=true); persist(); applyListRefPrefsToArea(); renderRows(); }); }
  if(resetAllStylesBtn){ resetAllStylesBtn.addEventListener('click', ()=>{
    Object.values(prefs.entries).forEach(e=>{ e.bold=false; e.italic=false; e.underline=false; e.fontSize=''; e.color=''; });
    (prefs.groups||[]).forEach(g=>{ g.styles = g.styles || {}; g.styles.bold=false; g.styles.italic=false; g.styles.underline=false; g.styles.fontSize=''; g.styles.color=''; });
    persist(); applyListRefPrefsToArea(); renderRows();
  }); }
  if(addGroupBtn){ addGroupBtn.addEventListener('click', ()=>{
    const name = (newGroupNameIn?.value || '').trim() || 'Group';
    const id = 'g_' + Date.now().toString(36) + '_' + Math.floor(Math.random()*1000);
    const g = { id, name, order: [], styles: { hidden:false, bold:false, italic:false, underline:false, fontSize:'', color:'' } };
    prefs.groups = Array.isArray(prefs.groups) ? prefs.groups : [];
    prefs.groups.push(g);
    if(newGroupNameIn) newGroupNameIn.value = '';
    persist(); renderRows(); applyListRefPrefsToArea();
  }); }
  function renderRows(){
    rowsHost.innerHTML='';
    const groupedIds = new Set();
    // Render groups first
    if(groupsHost){
      groupsHost.innerHTML = '';
      (prefs.groups||[]).forEach((g, gi)=>{
        const groupDiv = document.createElement('div'); groupDiv.className='lr-group';
        const header = document.createElement('div'); header.className='lr-group-header';
        const nameIn = document.createElement('input'); nameIn.type='text'; nameIn.placeholder='Group name'; nameIn.value = g.name||''; nameIn.style.padding='4px 6px'; nameIn.style.border='1px solid #e5e5e5'; nameIn.style.borderRadius='6px';
        nameIn.addEventListener('input', ()=>{ g.name = nameIn.value; persist(); });
        const upBtn = document.createElement('button'); upBtn.className='small-btn secondary'; upBtn.textContent='↑'; upBtn.title='Move group earlier';
        const dnBtn = document.createElement('button'); dnBtn.className='small-btn secondary'; dnBtn.textContent='↓'; dnBtn.title='Move group later';
        upBtn.addEventListener('click', ()=>{ moveGroup(gi,-1); }); dnBtn.addEventListener('click', ()=>{ moveGroup(gi,1); });
        // Group style controls
        const hideBtn = document.createElement('button'); hideBtn.className='small-btn'; hideBtn.title='Toggle group visibility';
  g.styles = g.styles || {};
        function setHideIcon(){ hideBtn.textContent = g.styles.hidden ? '🙈' : '👁️'; }
        setHideIcon();
  hideBtn.addEventListener('click', ()=>{ if(g.styles.hidden){ delete g.styles.hidden; } else { g.styles.hidden = true; } setHideIcon(); persist(); applyListRefPrefsToArea(); renderRows(); });
  const b = mkToggle('B', 'Bold', !!g.styles.bold, v=>{ if(v) g.styles.bold=true; else delete g.styles.bold; persist(); applyListRefPrefsToArea(); });
  const i = mkToggle('I', 'Italic', !!g.styles.italic, v=>{ if(v) g.styles.italic=true; else delete g.styles.italic; persist(); applyListRefPrefsToArea(); });
  const u = mkToggle('U', 'Underline', !!g.styles.underline, v=>{ if(v) g.styles.underline=true; else delete g.styles.underline; persist(); applyListRefPrefsToArea(); });
        const sizeIn = document.createElement('input'); sizeIn.type='number'; sizeIn.placeholder='size px'; sizeIn.min='8'; sizeIn.max='48'; sizeIn.step='1'; sizeIn.style.width='84px'; sizeIn.value = g.styles.fontSize||'';
  sizeIn.addEventListener('input', ()=>{ if(sizeIn.value) g.styles.fontSize = sizeIn.value; else delete g.styles.fontSize; persist(); applyListRefPrefsToArea(); });
  const colorIn = document.createElement('input'); colorIn.type='color'; colorIn.value = g.styles.color || '#000000'; colorIn.title = 'Text color'; colorIn.addEventListener('input', ()=>{ if(colorIn.value) g.styles.color = colorIn.value; else delete g.styles.color; persist(); applyListRefPrefsToArea(); });
        const colorWrap = document.createElement('span'); colorWrap.className='lr-chip'; colorWrap.title='Text color'; colorWrap.appendChild(colorIn);
        const sizeWrap = document.createElement('span'); sizeWrap.className='lr-chip'; sizeWrap.title='Font size (px)'; sizeWrap.appendChild(sizeIn);
        // Remove group
        const resetStyleBtn = document.createElement('button'); resetStyleBtn.className='small-btn secondary'; resetStyleBtn.textContent='Reset style'; resetStyleBtn.title='Clear visibility and styles for this group and its items';
        resetStyleBtn.addEventListener('click', ()=>{
          // Clear group styles including visibility
          g.styles = {};
          // Also clear individual styles/visibility for items in this group
          (g.order||[]).forEach(id=>{ const e=prefs.entries[id]; if(e){ delete e.hidden; delete e.bold; delete e.italic; delete e.underline; delete e.fontSize; delete e.color; } });
          persist(); applyListRefPrefsToArea(); renderRows();
        });
  const del = document.createElement('button'); del.className='small-btn secondary'; del.textContent='Remove group'; del.addEventListener('click', ()=>{ prefs.groups.splice(gi,1); persist(); renderRows(); applyListRefPrefsToArea(); });
  header.appendChild(upBtn); header.appendChild(dnBtn); header.appendChild(nameIn); header.appendChild(hideBtn); header.appendChild(b); header.appendChild(i); header.appendChild(u); header.appendChild(sizeWrap); header.appendChild(colorWrap); header.appendChild(resetStyleBtn); header.appendChild(del);
        groupDiv.appendChild(header);
        // Items: ordered rows with membership toggle, up/down, and per-item style controls
        const itemsDiv = document.createElement('div'); itemsDiv.className='lr-group-items';
        const allIds = prefs.order.filter(id=> labels.includes(id));
        g.order = Array.isArray(g.order) ? g.order.filter(id=> allIds.includes(id)) : [];
        const inGroup = new Set(g.order);
        // Membership selector to add new items into group
        const addWrap = document.createElement('div'); addWrap.style.marginBottom='6px';
        const addSelect = document.createElement('select'); addSelect.title='Add item to group';
        const defaultOpt = document.createElement('option'); defaultOpt.value=''; defaultOpt.textContent='Add item to group…'; addSelect.appendChild(defaultOpt);
        allIds.forEach(id=>{ if(inGroup.has(id)) return; const opt=document.createElement('option'); opt.value=id; opt.textContent=id; addSelect.appendChild(opt); });
        addSelect.addEventListener('change', ()=>{
          const id = addSelect.value; if(!id) return; g.order.push(id); persist(); applyListRefPrefsToArea(); renderRows(); });
        addWrap.appendChild(addSelect); itemsDiv.appendChild(addWrap);
        // Render existing members in g.order
        g.order.forEach((id, idx)=>{
          groupedIds.add(id);
          const ent = prefs.entries[id]; if(!ent) return;
          const row = document.createElement('div'); row.className='lr-row';
          const upBtn = document.createElement('button'); upBtn.className='small-btn secondary'; upBtn.textContent='↑'; upBtn.title='Move earlier';
          const dnBtn = document.createElement('button'); dnBtn.className='small-btn secondary'; dnBtn.textContent='↓'; dnBtn.title='Move later';
          upBtn.addEventListener('click', ()=>{ moveInGroup(gi, idx, -1); });
          dnBtn.addEventListener('click', ()=>{ moveInGroup(gi, idx, +1); });
          row.appendChild(upBtn); row.appendChild(dnBtn);
          const abbr = document.createElement('span'); abbr.className='lr-abbr'; abbr.textContent=id; row.appendChild(abbr);
          const styleControls = document.createElement('div'); styleControls.style.display='flex'; styleControls.style.alignItems='center'; styleControls.style.gap='8px';
          const hideBtn = document.createElement('button'); hideBtn.className='small-btn'; hideBtn.title='Toggle visibility';
          function setHideIcon(){ hideBtn.textContent = ent.hidden ? '🙈' : '👁️'; }
          setHideIcon();
          hideBtn.addEventListener('click', ()=>{ if(ent.hidden){ delete ent.hidden; } else { ent.hidden = true; } setHideIcon(); persist(); applyListRefPrefsToArea(); renderRows(); });
          styleControls.appendChild(hideBtn);
          const b = mkToggle('B', 'Bold', !!ent.bold, v=>{ if(v) ent.bold=true; else delete ent.bold; persist(); applyListRefPrefsToArea(); });
          const i = mkToggle('I', 'Italic', !!ent.italic, v=>{ if(v) ent.italic=true; else delete ent.italic; persist(); applyListRefPrefsToArea(); });
          const u = mkToggle('U', 'Underline', !!ent.underline, v=>{ if(v) ent.underline=true; else delete ent.underline; persist(); applyListRefPrefsToArea(); });
          const sizeIn = document.createElement('input'); sizeIn.type='number'; sizeIn.placeholder='size px'; sizeIn.min='8'; sizeIn.max='48'; sizeIn.step='1'; sizeIn.style.width='84px'; sizeIn.value = ent.fontSize || '';
          sizeIn.addEventListener('input', ()=>{ if(sizeIn.value) ent.fontSize = sizeIn.value; else delete ent.fontSize; persist(); applyListRefPrefsToArea(); });
          const colorIn = document.createElement('input'); colorIn.type='color'; colorIn.value = ent.color || '#000000'; colorIn.title = 'Text color'; colorIn.addEventListener('input', ()=>{ if(colorIn.value) ent.color = colorIn.value; else delete ent.color; persist(); applyListRefPrefsToArea(); });
          const sizeWrap = document.createElement('span'); sizeWrap.className='lr-chip'; sizeWrap.title='Font size (px)'; sizeWrap.appendChild(sizeIn);
          const colorWrap = document.createElement('span'); colorWrap.className='lr-chip'; colorWrap.title='Text color'; colorWrap.appendChild(colorIn);
          const resetStyleBtn = document.createElement('button'); resetStyleBtn.className='small-btn secondary'; resetStyleBtn.textContent='Reset style'; resetStyleBtn.title='Clear visibility and styles for this item';
          resetStyleBtn.addEventListener('click', ()=>{ delete ent.hidden; delete ent.bold; delete ent.italic; delete ent.underline; delete ent.fontSize; delete ent.color; persist(); applyListRefPrefsToArea(); renderRows(); });
          // Remove from group
          const removeBtn = document.createElement('button'); removeBtn.className='small-btn secondary'; removeBtn.textContent='Remove from group'; removeBtn.addEventListener('click', ()=>{ g.order.splice(idx,1); persist(); applyListRefPrefsToArea(); renderRows(); });
          styleControls.appendChild(b); styleControls.appendChild(i); styleControls.appendChild(u); styleControls.appendChild(sizeWrap); styleControls.appendChild(colorWrap); styleControls.appendChild(resetStyleBtn); styleControls.appendChild(removeBtn);
          row.appendChild(styleControls);
          itemsDiv.appendChild(row);
        });
        groupDiv.appendChild(itemsDiv);
        groupsHost.appendChild(groupDiv);
      });
    }
    // Then render ungrouped items in the main list
    prefs.order.forEach(label=>{
      if(groupedIds.has(label)) return;
      const ent = prefs.entries[label]; if(!ent) return;
      const row = document.createElement('div'); row.className = 'lr-row';
      // Up/Down before abbreviation
      const upBtn = document.createElement('button'); upBtn.className='small-btn secondary'; upBtn.textContent='↑'; upBtn.title='Move earlier';
      const dnBtn = document.createElement('button'); dnBtn.className='small-btn secondary'; dnBtn.textContent='↓'; dnBtn.title='Move later';
      upBtn.addEventListener('click', ()=>{ move(label, -1); }); dnBtn.addEventListener('click', ()=>{ move(label, +1); });
      row.appendChild(upBtn); row.appendChild(dnBtn);
      // Abbreviation next
      const abbr = document.createElement('span'); abbr.className = 'lr-abbr'; abbr.textContent = label; row.appendChild(abbr);
      const styleControls = document.createElement('div');
      styleControls.style.display='flex'; styleControls.style.alignItems='center'; styleControls.style.gap='8px';
      // Hide as first style option (eye icon)
      const hideBtn = document.createElement('button'); hideBtn.className='small-btn'; hideBtn.title='Toggle visibility';
      function setHideIcon(){ hideBtn.textContent = ent.hidden ? '🙈' : '👁️'; }
      setHideIcon();
  hideBtn.addEventListener('click', ()=>{ if(ent.hidden){ delete ent.hidden; } else { ent.hidden = true; } setHideIcon(); persist(); applyListRefPrefsToArea(); renderHiddenVisual(); renderRows(); });
      styleControls.appendChild(hideBtn);
  const b = mkToggle('B', 'Bold', !!ent.bold, v=>{ if(v) ent.bold=true; else delete ent.bold; persist(); applyListRefPrefsToArea(); });
  const i = mkToggle('I', 'Italic', !!ent.italic, v=>{ if(v) ent.italic=true; else delete ent.italic; persist(); applyListRefPrefsToArea(); });
  const u = mkToggle('U', 'Underline', !!ent.underline, v=>{ if(v) ent.underline=true; else delete ent.underline; persist(); applyListRefPrefsToArea(); });
      const sizeIn = document.createElement('input'); sizeIn.type='number'; sizeIn.placeholder='size px'; sizeIn.min='8'; sizeIn.max='48'; sizeIn.step='1';
      sizeIn.value = ent.fontSize || '';
      sizeIn.style.width='84px';
  sizeIn.addEventListener('input', ()=>{ if(sizeIn.value) ent.fontSize = sizeIn.value; else delete ent.fontSize; persist(); applyListRefPrefsToArea(); });
  const colorIn = document.createElement('input'); colorIn.type='color'; colorIn.value = ent.color || '#000000'; colorIn.title = 'Text color'; colorIn.addEventListener('input', ()=>{ if(colorIn.value) ent.color = colorIn.value; else delete ent.color; persist(); applyListRefPrefsToArea(); });
      styleControls.appendChild(b); styleControls.appendChild(i); styleControls.appendChild(u);
  const sizeWrap = document.createElement('span'); sizeWrap.className='lr-chip'; sizeWrap.title='Font size (px)'; sizeWrap.appendChild(sizeIn);
      const colorWrap = document.createElement('span'); colorWrap.className='lr-chip'; colorWrap.title='Text color'; colorWrap.appendChild(colorIn);
  const resetStyleBtn = document.createElement('button'); resetStyleBtn.className='small-btn secondary'; resetStyleBtn.textContent='Reset style'; resetStyleBtn.title='Clear visibility and styles for this item';
  resetStyleBtn.addEventListener('click', ()=>{ delete ent.hidden; delete ent.bold; delete ent.italic; delete ent.underline; delete ent.fontSize; delete ent.color; persist(); applyListRefPrefsToArea(); renderHiddenVisual(); renderRows(); });
  styleControls.appendChild(sizeWrap);
      styleControls.appendChild(colorWrap);
  styleControls.appendChild(resetStyleBtn);
      row.appendChild(styleControls);
      function renderHiddenVisual(){ if(ent.hidden) abbr.classList.add('is-hidden'); else abbr.classList.remove('is-hidden'); }
      renderHiddenVisual();
      rowsHost.appendChild(row);
    });
  }
  function mkToggle(txt, title, on, cb){ const b = document.createElement('button'); b.className='small-btn'; b.textContent=txt; b.title=title; b.style.fontWeight= on?'700':'400'; b.style.textDecoration = txt==='U' && on ? 'underline':'none'; b.style.fontStyle = txt==='I' && on ? 'italic':'normal'; b.addEventListener('click', ()=>{ const v = !(txt==='B'? (b.style.fontWeight==='700') : txt==='I' ? (b.style.fontStyle==='italic') : (b.style.textDecoration==='underline')); if(txt==='B') b.style.fontWeight = v?'700':'400'; if(txt==='I') b.style.fontStyle = v?'italic':'normal'; if(txt==='U') b.style.textDecoration = v?'underline':'none'; cb(v); }); return b; }
  function move(label, delta){ const idx = prefs.order.indexOf(label); const j = idx + delta; if(j<0||j>=prefs.order.length) return; const t=prefs.order[idx]; prefs.order[idx]=prefs.order[j]; prefs.order[j]=t; persist(); renderRows(); applyListRefPrefsToArea(); }
  function moveInGroup(gi, idx, delta){ const g=prefs.groups[gi]; if(!g||!Array.isArray(g.order)) return; const j = idx + delta; if(j<0||j>=g.order.length) return; const t=g.order[idx]; g.order[idx]=g.order[j]; g.order[j]=t; persist(); renderRows(); applyListRefPrefsToArea(); }
  function moveGroup(gi, delta){ const j = gi + delta; if(j<0||j>=prefs.groups.length) return; const t=prefs.groups[gi]; prefs.groups[gi]=prefs.groups[j]; prefs.groups[j]=t; persist(); renderRows(); applyListRefPrefsToArea(); }
  function persist(){ globalState.listRefPrefs = prefs; saveListRefPrefs(prefs); }
  renderRows();
  // apply immediately
  applyListRefPrefsToArea();
  // Wire Reset order: recompute suggestion from current XML and apply
  if(resetBtn && panel.dataset.resetWired !== '1'){
    resetBtn.addEventListener('click', ()=>{
      try{
        // Recompute suggested from last XML in memory is not stored; call compute on window XML via last transform input
        // We don't have the last xmlDoc stored globally; instead, re-derive labels suggestion from the same XML we used earlier.
        // As a practical approach, we will use the last computed suggestedOrder passed in, or recompute from Abbrev XML if available.
        // Since suggestedOrder is passed into this builder, prefer reusing it.
        const suggestion = Array.isArray(suggestedOrder) ? suggestedOrder.slice() : [];
        // Clear saved order and adopt suggestion
        prefs.order = reconcileListRefPrefs({ entries: prefs.entries, order: [] }, labels, suggestion).order;
        persist();
        renderRows();
        applyListRefPrefsToArea();
      }catch(_){ /* no-op */ }
    });
    panel.dataset.resetWired = '1';
  }
}
function applyListRefPrefsToArea(){
  const area = byId('renderArea'); if(!area) return;
  const prefs = globalState.listRefPrefs || loadListRefPrefs();
  // For each interlinear cell, reorder contiguous runs of listRef pairs based on prefs.order (if enforce enabled)
  const cells = Array.from(area.querySelectorAll('.interlinear'));
  cells.forEach(cell=>{
    // collect siblings and identify listRef pairs
    const pairs = Array.from(cell.querySelectorAll(':scope > .pair'));
    // Walk and process runs of listRef pairs
    let i=0; while(i < pairs.length){
      if(!pairs[i].classList.contains('listRef')){ i++; continue; }
      let j=i; const run=[]; while(j<pairs.length && pairs[j].classList.contains('listRef')){ run.push(pairs[j]); j++; }
      const mode = prefs.enforceMode || (typeof prefs.enforce === 'boolean' ? (prefs.enforce ? 'global' : 'none') : 'global');
      if(mode !== 'none'){
        // Ensure we keep original order metadata for later restoration
        run.forEach((n, idx)=>{ if(!n.hasAttribute('data-orig-index')) n.setAttribute('data-orig-index', String(idx)); });
        // sort run by prefs.order using each node's data-listref
        // If groups are defined and a token is a member of a group, rank by group order first (index of group), then within-group order, then fallback to global order (only when mode==='global')
        const groupIndexFor = (lab)=>{
          const groups = prefs.groups||[];
          for(let gi=0; gi<groups.length; gi++){
            const g = groups[gi];
            if(Array.isArray(g.order) && g.order.includes(lab)) return gi;
          }
          return Number.MAX_SAFE_INTEGER;
        };
        const inGroupPos = (lab)=>{
          const groups = prefs.groups||[];
          for(let gi=0; gi<groups.length; gi++){
            const g = groups[gi];
            if(Array.isArray(g.order)){
              const k = g.order.indexOf(lab);
              if(k !== -1) return k;
            }
          }
          return Number.MAX_SAFE_INTEGER;
        };
        const globalIndex = (lab)=>{ const k=(lab||'').trim(); const idx=prefs.order.indexOf(k); return idx===-1? Number.MAX_SAFE_INTEGER: idx; };
        // In groups-only mode, we only sort within adjacent clusters of the same group.
        run.sort((a,b)=>{
          const la = (a.getAttribute('data-listref')||'').trim();
          const lb = (b.getAttribute('data-listref')||'').trim();
          const ga = groupIndexFor(la), gb = groupIndexFor(lb);
          if(ga !== gb){
            // Different groups or one ungrouped vs grouped: don't intermix in groups-only mode, keep original order for both
            if(mode === 'groups'){
              const oa = parseInt(a.getAttribute('data-orig-index')||'0',10);
              const ob = parseInt(b.getAttribute('data-orig-index')||'0',10);
              return oa - ob;
            }
            return ga - gb;
          }
          const pa = inGroupPos(la), pb = inGroupPos(lb);
          if(pa !== pb){
            if(mode === 'groups') return pa - pb; // same group cluster: apply within-group order
            return pa - pb;
          }
          if(mode === 'groups'){
            // identical positions (likely same token or ambiguous), keep source order
            const oa = parseInt(a.getAttribute('data-orig-index')||'0',10);
            const ob = parseInt(b.getAttribute('data-orig-index')||'0',10);
            return oa - ob;
          }
          return globalIndex(la) - globalIndex(lb);
        });
        if(prefs.reverse) run.reverse();
        // reinsert in DOM in this new order
        const before = pairs[j] || null; // node after run
        run.forEach(n=> cell.insertBefore(n, before));
      } else {
        // Restore to original XML order using data-orig-index (fallback to current order if not present)
        run.forEach((n, idx)=>{ if(!n.hasAttribute('data-orig-index')) n.setAttribute('data-orig-index', String(idx)); });
        run.sort((a,b)=> (parseInt(a.getAttribute('data-orig-index')||'0',10) - parseInt(b.getAttribute('data-orig-index')||'0',10)) );
        if(prefs.reverse) run.reverse();
        const before = pairs[j] || null;
        run.forEach(n=> cell.insertBefore(n, before));
      }
      i = j; // advance
    }
  });
  // In groups-only mode, surface warnings for group members that are not adjacent within a run
  try{
    const mode = (globalState.listRefPrefs || {}).enforceMode || 'global';
    const warnHost = byId('listRefWarnings');
    if(warnHost){ warnHost.style.display='none'; warnHost.innerHTML=''; }
    if(mode === 'groups'){
      const runs = [];
      const cells2 = Array.from(area.querySelectorAll('.interlinear'));
      cells2.forEach(cell=>{
        const pairs2 = Array.from(cell.querySelectorAll(':scope > .pair'));
        let i2=0; while(i2<pairs2.length){
          if(!pairs2[i2].classList.contains('listRef')){ i2++; continue; }
          let j2=i2; const runNodes=[]; while(j2<pairs2.length && pairs2[j2].classList.contains('listRef')){ runNodes.push(pairs2[j2]); j2++; }
          // Derive row/column context
          const td = cell.closest('td,th');
          let tr = null, col = 0, rowLabel = '';
          if(td){
            tr = td.parentElement;
            const cellsInRow = Array.from(tr.children);
            col = cellsInRow.indexOf(td) + 1;
            const firstCell = cellsInRow[0];
            if(firstCell){ rowLabel = (firstCell.textContent || '').trim(); }
          }
          runs.push({ nodes: runNodes, rowLabel, col });
          i2=j2;
        }
      });
      const problems = [];
      (globalState.listRefPrefs.groups||[]).forEach(g=>{
        if(!Array.isArray(g.order) || g.order.length<2) return;
        runs.forEach(run=>{
          const present = g.order.filter(id=> run.nodes.some(n => (n.getAttribute('data-listref')||'').trim() === id));
          if(present.length >= 2){
            // Check adjacency in the run
            const indices = present.map(id => run.nodes.findIndex(n => (n.getAttribute('data-listref')||'').trim() === id)).sort((a,b)=>a-b);
            // If any consecutive desired members are separated by others, warn
            for(let k=1;k<indices.length;k++){
              if(indices[k] !== indices[k-1]+1){
                problems.push({ group: g.name || '(unnamed group)', ids: present, row: run.rowLabel || '(row)', col: run.col });
                break;
              }
            }
          }
        });
      });
      if(problems.length && warnHost){
        const uniq = [];
        const seen = new Set();
        problems.forEach(p=>{ const key=p.group+':' + p.ids.join('|') + ':' + p.row + ':' + p.col; if(!seen.has(key)){ seen.add(key); uniq.push(p); } });
        warnHost.style.display='block';
        warnHost.innerHTML = 'Note: Some group members are not adjacent in the source. Consider adjusting the sequence in FLEx if strict adjacency matters.' +
          '<br>' + uniq.map(p => `• Group ${escapeHtml(p.group)} at row ${escapeHtml(p.row)}, column ${p.col}: ${p.ids.map(escapeHtml).join(', ')}`).join('<br>');
      }
    }
  }catch(_){/* non-fatal */}
  // Apply style/visibility per label, including group-level overrides (group styles apply first, item styles override when set)
  const nodes = Array.from(area.querySelectorAll('.interlinear .pair.listRef[data-listref]'));
  nodes.forEach(n=>{
    const lab = (n.getAttribute('data-listref')||'').trim(); const ent = prefs.entries && prefs.entries[lab];
    // Resolve group membership and styles
    let gstyles = {};
    const g = (prefs.groups||[]).find(g=> Array.isArray(g.order) && g.order.includes(lab));
    if(g && g.styles) gstyles = { ...gstyles, ...g.styles };
    const final = { ...gstyles };
    if(ent){
      ['hidden','bold','italic','underline','fontSize','color'].forEach(k=>{
        if(ent[k] !== undefined && ent[k] !== '' && ent[k] !== null) final[k] = ent[k];
      });
    }
    n.style.display = final.hidden ? 'none' : '';
    const w = n.querySelector(':scope > .w'); if(w){
      w.style.fontWeight = final.bold ? '700' : '';
      w.style.fontStyle = final.italic ? 'italic' : '';
      w.style.textDecoration = final.underline ? 'underline' : '';
      w.style.fontSize = final.fontSize ? (parseInt(final.fontSize,10)||0) + 'px' : '';
      w.style.color = final.color || '';
    }
  });
}
/* ===== Abbreviations (listRef) controls and render ===== */
function collectListRefLabelsFromXml(xmlDoc){
  if(!xmlDoc) return [];
  const nodes = Array.from(xmlDoc.getElementsByTagName('listRef'));
  const set = new Set();
  nodes.forEach(n=>{
    const t = (n.textContent || '').trim();
    if(t) set.add(t);
  });
  return Array.from(set).sort((a,b)=> a.localeCompare(b, undefined, { numeric:true, sensitivity:'base' }));
}
function loadAbbrevPrefs(){
  const d = loadJSON(ABBREV_PREFS_KEY) || {};
  return {
    include: typeof d.include === 'boolean' ? d.include : true,
    position: d.position === 'bottom' ? 'bottom' : 'top',
    entries: d.entries || {}
  };
}
function saveAbbrevPrefs(p){ saveJSON(ABBREV_PREFS_KEY, p); }
function reconcileAbbrevPrefsWithLabels(prefs, labels){
  const out = { include: prefs.include, position: prefs.position, entries: { ...prefs.entries } };
  // Remove stale CHART entries; keep MANUAL ones always
  Object.keys(out.entries).forEach(k=>{
    const e = out.entries[k] || {};
    const isManual = e.src === 'manual' || String(k).startsWith('__manual__');
    if(!isManual){
      // chart-sourced entries are removed if no longer present
      if(!labels.includes(e.abbr || k)) delete out.entries[k];
    }
  });
  // Ensure entry for each label
  labels.forEach(l=>{
    const existing = out.entries[l] || Object.values(out.entries).find(e => e.abbr === l && e.src !== 'manual');
    if(!existing){
      out.entries[l] = { abbr: l, name: '', def: '', src: 'chart' };
    } else {
      // migrate legacy shape {label, def} where label was previously editable: treat it as name
      const e = existing;
      if(e.label !== undefined && e.name === undefined){ e.name = e.label || ''; delete e.label; }
      if(e.abbr === undefined) e.abbr = l;
      if(e.def === undefined) e.def = '';
      if(e.src === undefined) e.src = 'chart';
      // If existing is not keyed by l, re-key it
      if(!out.entries[l]){
        // find its key
        const kFound = Object.keys(out.entries).find(k => out.entries[k] === e);
        if(kFound && kFound !== l){ delete out.entries[kFound]; out.entries[l] = e; }
      }
    }
  });
  return out;
}
function showAbbrevPanel(show){ byId('abbrevPanel').style.display = show ? 'block' : 'none'; }
function buildAbbrevControls(labels){
  const panel = byId('abbrevPanel'); if(!panel) return;
  const includeCb = byId('abbrevInclude');
  const posSel = byId('abbrevPosition');
  const rowsHost = byId('abbrevRows');
  const emptyMsg = byId('abbrevEmptyMsg');
  const resetBtn = byId('abbrevResetFromChart');
  const addBtn = byId('abbrevAddManual');
  globalState.abbrevPrefs = reconcileAbbrevPrefsWithLabels(loadAbbrevPrefs(), labels);
  includeCb.checked = !!globalState.abbrevPrefs.include;
  posSel.value = globalState.abbrevPrefs.position;
  function renderRows(){
    rowsHost.innerHTML = '';
    const keys = Object.keys(globalState.abbrevPrefs.entries);
    emptyMsg.style.display = keys.length ? 'none' : 'block';
    keys.sort((a,b)=> a.localeCompare(b, undefined, {numeric:true,sensitivity:'base'})).forEach(k=>{
      const ent = globalState.abbrevPrefs.entries[k];
      const row = document.createElement('div'); row.className = 'abbr-row';
      let abbrCell;
      const isManual = ent.src === 'manual' || String(k).startsWith('__manual__');
      if(isManual){
        const abbrIn = document.createElement('input'); abbrIn.type = 'text'; abbrIn.value = ent.abbr || ''; abbrIn.placeholder = 'Abbreviation (incl. parentheses)';
        abbrIn.addEventListener('input', ()=>{
          ent.abbr = abbrIn.value;
          // If abbr is valid and unique, migrate key
          const trimmed = (ent.abbr || '').trim();
          if(trimmed && !globalState.abbrevPrefs.entries[trimmed]){
            delete globalState.abbrevPrefs.entries[k];
            globalState.abbrevPrefs.entries[trimmed] = ent;
            saveAbbrevPrefs(globalState.abbrevPrefs);
            renderRows();
            applyAbbrevToRenderArea(globalState.abbrevPrefs);
          } else {
            saveAbbrevPrefs(globalState.abbrevPrefs);
            applyAbbrevToRenderArea(globalState.abbrevPrefs);
          }
        });
        abbrCell = abbrIn;
      } else {
        const abbrEl = document.createElement('span'); abbrEl.className = 'abbr-abbr'; abbrEl.textContent = ent.abbr || k; abbrCell = abbrEl;
      }
      const nameIn = document.createElement('input'); nameIn.type = 'text'; nameIn.value = ent.name || ''; nameIn.placeholder = 'Name';
      const defIn = document.createElement('input'); defIn.type = 'text'; defIn.value = ent.def || ''; defIn.placeholder = 'Description (optional)';
      nameIn.addEventListener('input', ()=>{ ent.name = nameIn.value; saveAbbrevPrefs(globalState.abbrevPrefs); applyAbbrevToRenderArea(globalState.abbrevPrefs); });
      defIn.addEventListener('input', ()=>{ ent.def = defIn.value; saveAbbrevPrefs(globalState.abbrevPrefs); applyAbbrevToRenderArea(globalState.abbrevPrefs); });
      row.appendChild(abbrCell); row.appendChild(nameIn); row.appendChild(defIn);
      if(isManual){
        const delBtn = document.createElement('button'); delBtn.className = 'small-btn secondary'; delBtn.textContent = 'Remove';
        delBtn.addEventListener('click', ()=>{
          delete globalState.abbrevPrefs.entries[k];
          saveAbbrevPrefs(globalState.abbrevPrefs);
          renderRows();
          applyAbbrevToRenderArea(globalState.abbrevPrefs);
        });
        // make a 4th column for remove button
        row.style.gridTemplateColumns = 'auto 1fr 2fr auto';
        row.appendChild(delBtn);
      }
      rowsHost.appendChild(row);
    });
  }
  if(panel.dataset.wired !== '1'){
    includeCb.addEventListener('change', ()=>{ globalState.abbrevPrefs.include = !!includeCb.checked; saveAbbrevPrefs(globalState.abbrevPrefs); applyAbbrevToRenderArea(globalState.abbrevPrefs); });
    posSel.addEventListener('change', ()=>{ globalState.abbrevPrefs.position = posSel.value === 'bottom' ? 'bottom':'top'; saveAbbrevPrefs(globalState.abbrevPrefs); applyAbbrevToRenderArea(globalState.abbrevPrefs); });
    resetBtn.addEventListener('click', ()=>{
      globalState.abbrevPrefs = reconcileAbbrevPrefsWithLabels(globalState.abbrevPrefs, globalState.chartAbbrevLabels || []);
      saveAbbrevPrefs(globalState.abbrevPrefs); renderRows(); applyAbbrevToRenderArea(globalState.abbrevPrefs);
    });
    addBtn.addEventListener('click', ()=>{
      // create a placeholder manual entry with a temp key
      const tempKey = '__manual__' + Date.now() + '_' + Math.floor(Math.random()*10000);
      globalState.abbrevPrefs.entries[tempKey] = { abbr: '', name: '', def: '', src: 'manual' };
      saveAbbrevPrefs(globalState.abbrevPrefs);
      renderRows();
      applyAbbrevToRenderArea(globalState.abbrevPrefs);
    });
    panel.dataset.wired = '1';
  }
  saveAbbrevPrefs(globalState.abbrevPrefs);
  renderRows();
  // Apply immediately to current render
  applyAbbrevToRenderArea(globalState.abbrevPrefs);
}
function applyAbbrevToRenderArea(prefs){
  const area = byId('renderArea'); if(!area) return;
  // Remove any existing blocks
  area.querySelectorAll(':scope > .chart-abbrev-block').forEach(n=> n.remove());
  if(!prefs || !prefs.include) return;
  const entries = Object.values(prefs.entries || {});
  if(!entries.length) return;
  const block = document.createElement('div'); block.className = 'chart-abbrev-block';
  const heading = document.createElement('h3'); heading.textContent = 'Abbreviations'; block.appendChild(heading);
  const list = document.createElement('ul');
  entries
    .sort((a,b)=> (a.abbr||'').localeCompare(b.abbr||'', undefined, {numeric:true,sensitivity:'base'}))
    .forEach(ent=>{
      const li = document.createElement('li');
      const abbr = (ent.abbr || '').trim();
      const name = (ent.name || '').trim();
      const def = (ent.def || '').trim();
      if(!abbr) return; // must have abbreviation
      let tail = '';
      if(name && def) tail = ` — ${escapeHtml(name)} — ${escapeHtml(def)}`;
      else if(name) tail = ` — ${escapeHtml(name)}`;
      else if(def) tail = ` — ${escapeHtml(def)}`;
      li.innerHTML = `<strong>${escapeHtml(abbr)}</strong>${tail}`;
      list.appendChild(li);
    });
  if(!list.childNodes.length) return;
  block.appendChild(list);
  // Insert at chosen position
  const prologue = area.querySelector(':scope > .chart-prologue');
  const table = area.querySelector('table.chartshell')?.closest('.chartshell-wrapper') || area.querySelector('table.chartshell');
  if(prefs.position === 'top'){
    if(prologue && prologue.nextSibling) area.insertBefore(block, prologue.nextSibling);
    else area.insertBefore(block, area.firstChild || null);
  } else {
    if(table && table.nextSibling) area.insertBefore(block, table.nextSibling);
    else area.appendChild(block);
  }
}
function applyPrologueToRenderArea(prefs){
  const area = byId('renderArea');
  if(!area) return;
  // Ensure a fixed container exists as the first child for prologue content
  let prologue = area.querySelector(':scope > .chart-prologue');
  if(!prologue){
    prologue = document.createElement('div');
    prologue.className = 'chart-prologue';
    // Insert after any before-prologue HTML if present
    const beforeBlock = area.querySelector(':scope > .inserted-html-before-prologue');
    if(beforeBlock && beforeBlock.nextSibling){
      area.insertBefore(prologue, beforeBlock.nextSibling);
    } else if(beforeBlock){
      area.appendChild(prologue);
    } else {
      area.insertBefore(prologue, area.firstChild || null);
    }
  }
  prologue.innerHTML = '';
  const { tag, titleText } = (prefs || loadProloguePrefs());
  let { prefaceHtml, autoConvert } = (prefs || loadProloguePrefs());
  if(titleText && tag){
    const t = document.createElement(tag);
    t.textContent = titleText;
    prologue.appendChild(t);
  }
  if(prefaceHtml && prefaceHtml.trim()){
    // Convert plain text to HTML when auto-convert is on and content appears to be plain text.
    const appearsHtml = /<\s*[a-zA-Z!/]/.test(prefaceHtml);
    let htmlOut = prefaceHtml;
    if(autoConvert && !appearsHtml){
      // Treat double newlines as paragraph breaks, single newline as <br /> within a paragraph
      const norm = prefaceHtml.replace(/\r\n?/g, '\n');
      const paras = norm.split(/\n{2,}/).map(s => s.trim()).filter(Boolean);
      htmlOut = paras.map(p => `<p>${escapeHtml(p).replace(/\n/g, '<br />')}</p>`).join('\n');
    }
    const wrapper = document.createElement('div');
    wrapper.innerHTML = htmlOut;
    Array.from(wrapper.childNodes).forEach(n => prologue.appendChild(n));
  }
  // If both are empty, remove the container to avoid extra spacing
  if(!prologue.childNodes.length){ prologue.remove(); }
  // After updating prologue, re-render the Salience legend position
  try{ renderSalienceLegend(); }catch(_){ }
}

/* ===== Append external HTML before/after the chart ===== */
function showAppendHtmlPanel(show){ const p = byId('appendHtmlPanel'); if(p) p.style.display = show ? 'block' : 'none'; }
function sanitizeUserHtml(html){
  // strip <script> tags for safety
  try{
    const tmp = document.createElement('div');
    tmp.innerHTML = html || '';
    tmp.querySelectorAll('script').forEach(s=> s.remove());
    return tmp.innerHTML;
  }catch(_){ return html || ''; }
}
function applyAppendedHtmlToRenderArea(){
  const area = byId('renderArea'); if(!area) return;
  // Before-prologue block
  let before = area.querySelector(':scope > .inserted-html-before-prologue');
  if(globalState.beforeHtml){
    if(!before){ before = document.createElement('div'); before.className = 'inserted-html-before-prologue'; area.insertBefore(before, area.firstChild || null); }
    before.innerHTML = globalState.beforeHtml;
  } else if(before){ before.remove(); }

  // After-chart block: place after table, but before abbreviations if they are at bottom
  let after = area.querySelector(':scope > .inserted-html-after-chart');
  if(globalState.afterHtml){
    if(!after){ after = document.createElement('div'); after.className = 'inserted-html-after-chart'; }
    after.innerHTML = globalState.afterHtml;
    const tableWrap = area.querySelector('table.chartshell')?.closest('.chartshell-wrapper') || area.querySelector('table.chartshell');
    const abbrBlock = area.querySelector(':scope > .chart-abbrev-block');
    const abbrBottom = (globalState.abbrevPrefs && globalState.abbrevPrefs.include && globalState.abbrevPrefs.position === 'bottom');
    if(abbrBottom && abbrBlock){
      area.insertBefore(after, abbrBlock);
    } else if(tableWrap){
      if(tableWrap.nextSibling){ area.insertBefore(after, tableWrap.nextSibling); }
      else { area.appendChild(after); }
    } else {
      // fallback to end
      area.appendChild(after);
    }
  } else if(after){ after.remove(); }

  // Update small statuses
  const bstat = byId('beforeHtmlStatus'); if(bstat) bstat.textContent = globalState.beforeHtmlName ? `Attached: ${globalState.beforeHtmlName}` : '';
  const astat = byId('afterHtmlStatus'); if(astat) astat.textContent = globalState.afterHtmlName ? `Attached: ${globalState.afterHtmlName}` : '';
}
function initAppendHtmlControls(){
  const beforeIn = byId('beforeHtmlInput');
  const afterIn = byId('afterHtmlInput');
  const clearB = byId('clearBeforeHtmlBtn');
  const clearA = byId('clearAfterHtmlBtn');
  if(!beforeIn || !afterIn) return;
  const readFile = async (file)=>{ if(!file) return null; const txt = await file.text(); return sanitizeUserHtml(txt); };
  beforeIn.addEventListener('change', async e=>{
    const f = e.target.files && e.target.files[0];
    if(!f){ globalState.beforeHtml = null; globalState.beforeHtmlName=''; applyAppendedHtmlToRenderArea(); return; }
    globalState.beforeHtml = await readFile(f); globalState.beforeHtmlName = f.name || '';
    applyAppendedHtmlToRenderArea();
    // Re-insert prologue after the before block if needed
    applyPrologueToRenderArea(loadProloguePrefs());
    // Abbrev may need to shift down
    applyAbbrevToRenderArea(globalState.abbrevPrefs || loadAbbrevPrefs());
  });
  afterIn.addEventListener('change', async e=>{
    const f = e.target.files && e.target.files[0];
    if(!f){ globalState.afterHtml = null; globalState.afterHtmlName=''; applyAppendedHtmlToRenderArea(); return; }
    globalState.afterHtml = await readFile(f); globalState.afterHtmlName = f.name || '';
    applyAppendedHtmlToRenderArea();
  });
  clearB.addEventListener('click', ()=>{ globalState.beforeHtml=null; globalState.beforeHtmlName=''; beforeIn.value=''; applyAppendedHtmlToRenderArea(); applyPrologueToRenderArea(loadProloguePrefs()); applyAbbrevToRenderArea(globalState.abbrevPrefs || loadAbbrevPrefs()); });
  clearA.addEventListener('click', ()=>{ globalState.afterHtml=null; globalState.afterHtmlName=''; afterIn.value=''; applyAppendedHtmlToRenderArea(); });
}

/* ===== Main detection & dispatch ===== */
async function renderDocument(xmlDoc){
  // reset state
  globalState = { phonemeIndex:{}, idToNatclassIds:{}, natclassElements:{}, phonemeRowIds:{}, showNames: byId('showNames').checked };

  const root = xmlDoc.documentElement;
  const tag = root.nodeName.toLowerCase();
  const area = byId('renderArea');
  area.innerHTML = '';

  // Detect Text Chart (Discourse chart) and render via XSLT
  if(isTextChartDocument(xmlDoc)){
    const rendered = await renderTextChart(xmlDoc);
    area.innerHTML = '';
    showAppendHtmlPanel(true);
    // Initialize Append HTML controls once
    if(!byId('appendHtmlPanel').dataset.wired){ initAppendHtmlControls(); byId('appendHtmlPanel').dataset.wired = '1'; }
    // Apply any previously selected before-html prior to placing prologue
    applyAppendedHtmlToRenderArea();
    // Show prologue controls and inject current prologue before the chart
    showProloguePanel(true);
    // Wire collapsibles (collapsed by default; persisted)
    wireCollapsible('prologuePanel','prologueHeader');
    applyPrologueToRenderArea(loadProloguePrefs());
  // Show Postlogue controls (for export)
  showPostloguePanel(true);
  if(!byId('postloguePanel').dataset.wired){ initPostlogueControls(); byId('postloguePanel').dataset.wired = '1'; }
  wireCollapsible('postloguePanel','postlogueHeader');
  // Notes panel
  showNotesPanel(true);
  wireCollapsible('notesPanel','notesHeader');
  initNotesControls();
  // Free translations panel
  showFTPanel(true);
  wireCollapsible('ftPanel','ftHeader');
  initFTControls();
  // Salience bands panel
  showSaliencePanel(true);
  wireCollapsible('saliencePanel','salienceHeader');
  initSalienceControls();
    // Scan listRef abbreviations and show Abbrev controls
    globalState.chartAbbrevLabels = collectListRefLabelsFromXml(xmlDoc);
    showAbbrevPanel(true);
    wireCollapsible('abbrevPanel','abbrevHeader');
    buildAbbrevControls(globalState.chartAbbrevLabels);
    // Prepare ListRef controls (we will collect labels from rendered DOM; compute a suggested order from XML)
    const suggestedOrder = computeListRefSuggestedOrderFromXml(xmlDoc);
    showListRefPanel(true);
    wireCollapsible('listRefPanel','listRefHeader');
    if(rendered){
      area.appendChild(rendered);
      // Assign persistent GUIDs to body rows for stable associations
      try{
        const tbl = area.querySelector('table.chartshell');
        if(tbl){
          Array.from(tbl.querySelectorAll('tbody tr')).forEach(tr=>{
            if(tr.classList.contains('title1') || tr.classList.contains('title2') || tr.classList.contains('ft-inline')) return;
            getOrAssignRowGuid(tr);
          });
        }
      }catch(_){ }
      // Wire note tooltips after chart content is in the DOM
      if(window.wireNoteTooltips){ try{ window.wireNoteTooltips(); }catch(e){ console.error('Error wiring note tooltips:', e); } }
      // Enable column resizing on the text chart table
      enableTextChartColumnResize(area);
  // Wire Free Translation add/edit buttons and apply current display mode
  wireFreeTranslationButtons(area);
  applyFreeTranslationsToArea(area);
  // Wire Salience band buttons and apply to rows
  wireSalienceButtons(area);
  applySalienceBandsToArea(area);
  toggleSalienceColumn();
      // Apply freeze headers if saved and show control
      const fhc = byId('freezeHeadersContainer'); if(fhc) fhc.style.display = 'flex';
      initFreezeHeadersControl();
      const savedFreeze = loadJSON(FREEZE_HEADERS_KEY); setTimeout(()=> setFreezeHeadersEnabled(!!(savedFreeze && savedFreeze.enabled)), 0);
      // Ensure abbreviations block is positioned correctly relative to chart
      applyAbbrevToRenderArea(globalState.abbrevPrefs || loadAbbrevPrefs());
      // Now insert after-chart HTML in final position
      applyAppendedHtmlToRenderArea();
  // Insert/refresh salience legend below prologue and above chart
  renderSalienceLegend();
      wireCollapsible('appendHtmlPanel','appendHeader');
      // Insert Epilogue live preview at end
      applyEpilogueToRenderArea(loadPostloguePrefs());
      // Collect ListRef labels from rendered DOM (data-listref set by XSL), build controls with suggested order, and apply prefs
      globalState.listRefLabels = collectListRefLabelsFromRendered(area);
      buildListRefControls(globalState.listRefLabels, suggestedOrder);
    }
    else { area.textContent = 'Failed to render Text Chart.'; }
    // Show print-headers toggle when a Text Chart is displayed
  const rhc = byId('repeatHeadersContainer');
  if(rhc) rhc.style.display = 'flex';
  // Ensure the checkbox reflects saved preference and style is applied
  initRepeatHeadersControl();
  // If thead exists, apply current saved setting right now
  const saved = loadJSON(PRINT_HEADERS_KEY);
  const enabled = !!(saved && saved.enabled);
  setPrintHeadersEnabled(enabled);
    return;
  }

  // Order of detection: Phonology, Translated Lists (AUni multi), Monolingual list, Wordforms, Generic
  if(tag === 'phonology'){
    showProloguePanel(false);
    showAbbrevPanel(false);
    area.appendChild(renderPhonologyView(xmlDoc));
    return;
  }

  if(tag === 'list' || tag === 'lists'){
    // detect AUni-based multilingual lists
    const aunis = xmlDoc.querySelectorAll('AUni[ws]');
    const langSet = new Set(Array.from(aunis).map(a => a.getAttribute('ws')));
    if(langSet.size > 1){
      showProloguePanel(false);
      showAbbrevPanel(false);
      area.appendChild(renderTranslatedListView(root, Array.from(langSet)));
      return;
    } else {
      showProloguePanel(false);
      showAbbrevPanel(false);
      area.appendChild(renderListView(root));
      return;
    }
  }

  // Wordforms detection (FieldWorks uses a <wordforms> root or similar)
  const wfNodes = xmlDoc.getElementsByTagName('wordforms');
  if(wfNodes && wfNodes.length > 0){
    showProloguePanel(false);
    showAbbrevPanel(false);
    area.appendChild(renderWordformsView(xmlDoc));
    return;
  }

  // fallback generic
  showProloguePanel(false);
  showAbbrevPanel(false);
  showAppendHtmlPanel(false);
  area.appendChild(renderGenericView(root));
  // Hide print-headers toggle for non-TextChart views
  const rhc = byId('repeatHeadersContainer');
  if(rhc) rhc.style.display = 'none';
  const fhc2 = byId('freezeHeadersContainer');
  if(fhc2) fhc2.style.display = 'none';
  setPrintHeadersEnabled(false);
  showListRefPanel(false);
  showPostloguePanel(false);
}

/* ===== Salience Legend and Column ===== */
function renderSalienceLegend(){
  const area = byId('renderArea'); if(!area) return;
  // Remove existing legend
  area.querySelectorAll(':scope > .chart-salience-legend').forEach(n=> n.remove());
  const prefs = loadSaliencePrefs();
  if(!(prefs.enabled && prefs.showLegend)) return;
  // Build flat list from tree
  const nums = computeSalienceNumbers(prefs.tree);
  const items = [];
  (function walk(list){ (list||[]).forEach(n=>{ items.push({ id:n.id, num:nums[n.id]||'', label:n.label||'', color:n.color||findParentColor(prefs.tree, n.id)||'#fffad1' }); walk(n.children||[]); }); })(prefs.tree||[]);
  if(!items.length) return;
  const legend = document.createElement('div'); legend.className='chart-salience-legend';
  const h = document.createElement('h3'); h.textContent = 'Salience Scheme'; legend.appendChild(h);
  items.forEach(it=>{
    const row = document.createElement('div'); row.className='sal-row';
    const sw = document.createElement('span'); sw.className='sal-color'; sw.style.background = alphaColor(it.color, prefs.opacity);
    const num = document.createElement('strong'); num.textContent = it.num;
    const lab = document.createElement('span'); lab.textContent = it.label || '(unnamed)';
    row.appendChild(sw); row.appendChild(num); row.appendChild(lab); legend.appendChild(row);
  });
  // Insert after prologue, before chart
  const prologue = area.querySelector(':scope > .chart-prologue');
  if(prologue && prologue.nextSibling) area.insertBefore(legend, prologue.nextSibling);
  else area.insertBefore(legend, area.firstChild || null);
}
// Centralized visual refresh for salience after any change
function refreshSalienceVisuals(area){
  try{
    area = area || byId('renderArea');
    if(!area) return;
    // Apply row shading and ensure column content matches current prefs
    applySalienceBandsToArea(area);
    // Ensure salience column visibility and cells reflect the latest labels/colors
    toggleSalienceColumn();
    // Refresh the per-row picker button text and titles
    updateSalienceButtons(area);
    // Rebuild the legend
    renderSalienceLegend();
  }catch(_){ /* non-fatal */ }
}
function alphaColor(hex, a){
  try{
    const m = /^#([0-9a-f]{6}|[0-9a-f]{3})$/i.exec((hex||'').trim());
    if(!m) return hex;
    let r,g,b; const h=m[1];
    if(h.length===3){ r=parseInt(h[0]+h[0],16); g=parseInt(h[1]+h[1],16); b=parseInt(h[2]+h[2],16); }
    else { r=parseInt(h.slice(0,2),16); g=parseInt(h.slice(2,4),16); b=parseInt(h.slice(4,6),16); }
    const alpha = Math.max(0, Math.min(1, (typeof a==='number'?a:1)));
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }catch(_){ return hex; }
}
function toggleSalienceColumn(){
  const area = byId('renderArea'); if(!area) return;
  const prefs = loadSaliencePrefs();
  const tbl = area.querySelector('table.chartshell'); if(!tbl) return;
  const want = !!prefs.showColumn;
  // Determine if a salience column exists (look for th/td with data-sal-col="1")
  const has = !!tbl.querySelector('[data-sal-col="1"]');
  if(want && has){ updateSalienceColumnCells(tbl); return; }
  if(!want && has){ removeSalienceColumn(tbl); return; }
  if(want && !has){ addSalienceColumn(tbl); return; }
}
function addSalienceColumn(tbl){
  // Add a leading column in header rows and body rows
  const headRows = tbl.querySelectorAll('thead tr.row.title1, thead tr.row.title2');
  headRows.forEach(r=>{
    const th = document.createElement('th'); th.className='cell sal-cell'; th.textContent = r.classList.contains('title2') ? 'Salience' : '';
    th.setAttribute('data-sal-col','1');
    r.insertBefore(th, r.firstChild);
  });
  const bodyRows = tbl.querySelectorAll('tbody tr');
  bodyRows.forEach(r=>{
    if(r.classList.contains('ft-inline')) return;
    const td = document.createElement('td'); td.className='sal-cell'; td.setAttribute('data-sal-col','1');
    r.insertBefore(td, r.firstChild);
  });
  // Insert a new col element at the start of each colgroup for consistent widths
  tbl.querySelectorAll('colgroup').forEach(g=>{ const c = document.createElement('col'); g.insertBefore(c, g.firstChild); });
  updateSalienceColumnCells(tbl);
}
function removeSalienceColumn(tbl){
  tbl.querySelectorAll('[data-sal-col="1"]').forEach(n=> n.remove());
}
function updateSalienceColumnCells(tbl){
  const prefs = loadSaliencePrefs(); const nums = computeSalienceNumbers(prefs.tree);
  const idTo = {}; (function walk(list){ (list||[]).forEach(n=>{ idTo[n.id] = { num: nums[n.id]||'', label: n.label||'', color: n.color||findParentColor(prefs.tree, n.id)||'#fffad1' }; walk(n.children||[]); }); })(prefs.tree||[]);
  const rows = Array.from(tbl.querySelectorAll('tbody tr')).filter(r=> !r.classList.contains('ft-inline'));
  rows.forEach(r=>{
    const td = r.querySelector(':scope > td[data-sal-col="1"]'); if(!td) return;
    const label = computeRowLabelFromRow(r); const id = (prefs.assignments||{})[label];
    if(!id){ td.textContent = ''; td.style.background=''; return; }
    const meta = idTo[id]; if(!meta){ td.textContent=''; td.style.background=''; return; }
    td.innerHTML = `<span class="sal-pill">${meta.num}</span> ${escapeHtml(meta.label)}`;
    td.style.background = prefs.enabled ? alphaColor(meta.color, prefs.opacity) : '';
  });
}

/* ===== Text Chart detection and rendering (XSLT) ===== */
function isTextChartDocument(xmlDoc){
  if(!xmlDoc || !xmlDoc.documentElement) return false;
  // Typical structure: <document><chart>...</chart></document> or a top-level <chart>
  return !!(xmlDoc.querySelector('document > chart > row') || xmlDoc.querySelector('chart > row'));
}

async function loadTextChartXSL(){
  const url = `textchart/textchart-to-html.xsl?v=${Date.now()}`;
  const resp = await fetch(url);
  if(!resp.ok) throw new Error(`Failed to fetch XSL (${resp.status})`);
  const txt = await resp.text();
  const doc = new DOMParser().parseFromString(txt, 'text/xml');
  const err = doc.getElementsByTagName('parsererror')[0];
  if(err) throw new Error('XSL parse error: ' + err.textContent.trim());
  return doc;
}

async function renderTextChart(xmlDoc){
  if(typeof XSLTProcessor === 'undefined'){
    const frag = document.createDocumentFragment();
    frag.appendChild(create('div', {cls:'small-muted'}, 'XSLTProcessor not supported in this browser.'));
    return frag;
  }
  const xslDoc = await loadTextChartXSL();
  const proc = new XSLTProcessor();
  proc.importStylesheet(xslDoc);
  try{
    // Optional: pass through debug param from URL (?debug=1)
    const urlParams = new URLSearchParams(window.location.search);
    const dbg = urlParams.get('debug');
    if(dbg && ['1','true','yes','on'].includes(dbg.toLowerCase())){
      proc.setParameter(null, 'debug', 'true');
    }
    // Enable compact print class in-app; exports will remove the class
    proc.setParameter(null, 'printCompact', 'true');
    // Notes options from saved prefs
    const np = loadNotesPrefs();
    if(np && np.mode) proc.setParameter(null, 'notesAction', np.mode);
    if(np && typeof np.width === 'string') proc.setParameter(null, 'notesColWidth', np.width);
  }catch(_){/* no-op if params unsupported */}

  // Run transform to a fragment, then extract the body contents if present
  const frag = proc.transformToFragment(xmlDoc, document);
  const wrapper = document.createElement('div');
  wrapper.appendChild(frag);
  // If XSL produced a <head>, merge its styles into the page once
  const head = wrapper.querySelector('head');
  if (head) {
    // Inline <style>
    const styleEl = head.querySelector('style');
    if (styleEl) {
      const EXISTING_ID = 'textchart-xsl-style';
      let dest = document.getElementById(EXISTING_ID);
      if (!dest) {
        dest = document.createElement('style');
        dest.id = EXISTING_ID;
        document.head.appendChild(dest);
      }
      dest.textContent = styleEl.textContent || '';
    }
    // Linked stylesheets (if any in future)
    head.querySelectorAll('link[rel="stylesheet"][href]').forEach(link => {
      const href = link.getAttribute('href');
      if (!href) return;
      // Avoid duplicates by href
      const exists = Array.from(document.head.querySelectorAll('link[rel="stylesheet"][href]'))
        .some(l => l.getAttribute('href') === href);
      if (!exists) {
        const copy = document.createElement('link');
        copy.rel = 'stylesheet';
        copy.href = href;
        document.head.appendChild(copy);
      }
    });
  }
  const body = wrapper.querySelector('body');
  const outFrag = document.createDocumentFragment();
  const source = body || wrapper; // prefer body if the XSL produced a full HTML doc
  Array.from(source.childNodes).forEach(n => outFrag.appendChild(n));
  return outFrag;
}

/* ===== Monolingual List (unchanged behavior) ===== */
function renderListView(root) {
  // Accept either a single <list> or a top-level <lists> container
  if(!root) return create('div', {}, '(no list)');
  const nodeName = (root.nodeName || '').toLowerCase();
  if(nodeName === 'lists'){
    const outer = create('div');
    const lists = Array.from(root.querySelectorAll(':scope > list'));
    if(lists.length === 0) return outer;
    lists.forEach(l => outer.appendChild(renderListView(l)));
    return outer;
  }

  const container = create('div');
  // title: prefer Name or name inside the list; also accept a <name><str> pattern
  const title = (root.querySelector(':scope > name, :scope > Name')?.textContent?.trim()) || (root.querySelector(':scope > Name str, :scope > name str')?.textContent?.trim()) || 'List';
  container.appendChild(create('div', { cls: 'section-title' }, title));

  // helper to find direct "item-like" children (item, letitem, sditem)
  function itemChildrenOf(el){
    return Array.from(el.querySelectorAll(':scope > item, :scope > letitem, :scope > sditem'));
  }

  function buildItem(node) {
    const li = create('li');

    // collect children from direct item-like children and <subitems>
    const direct = itemChildrenOf(node);
    const subitemsContainer = node.querySelector(':scope > subitems');
    const sub = subitemsContainer ? itemChildrenOf(subitemsContainer) : [];
    const allChildren = direct.concat(sub);
    const hasChildren = allChildren.length > 0;

    // add toggle affordance (always present for consistent layout)
    const toggle = create('span', { cls: 'toggle' }, hasChildren ? '\u25be' : ' ');
    if(hasChildren) toggle.style.cursor = 'pointer';
    li.appendChild(toggle);

    // display name (handle <name ws="..."> and <name><str ws=...> patterns)
    const nameNode = node.querySelector(':scope > name, :scope > Name');
    const rawName = nameNode ? nameNode.textContent.trim() : (node.getAttribute && node.getAttribute('name')) || node.nodeName;
    const abbrNode = node.querySelector(':scope > abbr, :scope > Abbreviation');
    const abbrText = abbrNode ? abbrNode.textContent.trim() : (node.getAttribute && (node.getAttribute('abbr') || node.getAttribute('ws'))) || '';
    const text = abbrText ? `${rawName} (${abbrText})` : rawName;
    li.appendChild(document.createTextNode(text));

    if (hasChildren) {
      const ul = create('ul', { cls: 'tree' });
      allChildren.forEach(ci => ul.appendChild(buildItem(ci)));
      li.appendChild(ul);

      toggle.addEventListener('click', () => {
        li.classList.toggle('collapsed');
        toggle.textContent = toggle.textContent === '\u25be' ? '\u25b8' : '\u25be';
      });
    }

    return li;
  }

  // find top-level items: could be directly under list (item/letitem/sditem) or inside an <items> wrapper
  let topItems = itemChildrenOf(root);
  if(topItems.length === 0){
    const itemsWrapper = root.querySelector(':scope > items');
    if(itemsWrapper) topItems = itemChildrenOf(itemsWrapper);
  }

  const topUL = create('ul', { cls: 'tree' });
  topItems.forEach(it => topUL.appendChild(buildItem(it)));
  container.appendChild(topUL);

  return container;
}

/* ===== Translated (multilingual) List view + Language Controls ===== */
function renderTranslatedListView(root, langList){
  // canonicalize languages (stable order): prefer 'en' if present
  const langs = Array.from(langList);
  langs.sort((a,b)=>{
    if(a.toLowerCase().includes('en') && !b.toLowerCase().includes('en')) return -1;
    if(b.toLowerCase().includes('en') && !a.toLowerCase().includes('en')) return 1;
    return a.localeCompare(b);
  });

  // load saved prefs and merge defaults
  const saved = loadJSON(LANG_PREFS_KEY) || {};
  const prefs = {};
  langs.forEach((ws,i)=> {
    prefs[ws] = {
      ws,
      order: (saved[ws] && typeof saved[ws].order === 'number') ? saved[ws].order : i,
      visible: (saved[ws] && typeof saved[ws].visible === 'boolean') ? saved[ws].visible : true
    };
  });
  // compact orders
  const orderedLangs = Object.values(prefs).sort((a,b)=>a.order-b.order).map(l=>l.ws);
  orderedLangs.forEach((ws,i)=> prefs[ws].order = i);
  saveJSON(LANG_PREFS_KEY, prefs);

  const container = create('div');
  const title = root.querySelector(':scope > Name AUni[ws="en"], :scope > Name AUni, :scope > Name, :scope > name')?.textContent?.trim() || 'Translated List';
  container.appendChild(create('div', {cls:'section-title'}, title));

  const controls = create('div', {cls:'lang-controls'});
  container.appendChild(controls);

  function buildLangControls(){
    controls.innerHTML = '';
    const arr = Object.values(prefs).sort((a,b)=>a.order-b.order);
    arr.forEach((L, idx)=>{
      const item = create('div', {cls:'lang-item'});
      item.style.display = 'flex'; item.style.alignItems = 'center'; item.style.gap = '6px';

      const codeSpan = create('span', {}, L.ws);
      codeSpan.style.fontWeight = '600';
      item.appendChild(codeSpan);

      const up = create('button', {cls:'icon-btn', title:'Move up (higher priority)'}, '⬆️');
      up.addEventListener('click', ()=> { swapOrder(L.ws, -1); });
      item.appendChild(up);

      const down = create('button', {cls:'icon-btn', title:'Move down (lower priority)'}, '⬇️');
      down.addEventListener('click', ()=> { swapOrder(L.ws, +1); });
      item.appendChild(down);

      const vis = create('button', {cls:'icon-btn', title: L.visible ? 'Hide language' : 'Show language'}, L.visible ? '👁️' : '🚫');
      vis.addEventListener('click', ()=> { prefs[L.ws].visible = !prefs[L.ws].visible; saveJSON(LANG_PREFS_KEY, prefs); buildLangControls(); renderItems(); });
      item.appendChild(vis);

      controls.appendChild(item);
    });

    const reset = create('button', {cls:'small-btn secondary', title:'Reset language order and visibility to defaults'}, 'Reset');
    reset.addEventListener('click', ()=> {
      langs.forEach((ws,i)=> { prefs[ws].order = i; prefs[ws].visible = true; });
      saveJSON(LANG_PREFS_KEY, prefs); buildLangControls(); renderItems();
    });
    controls.appendChild(reset);
  }

  const listContainer = create('div');
  container.appendChild(listContainer);

  function renderItems(){
    listContainer.innerHTML = '';
    const ordered = Object.values(prefs).sort((a,b)=>a.order-b.order).filter(l=>l.visible).map(l=>l.ws);
    if(ordered.length === 0){
      listContainer.appendChild(create('div', {cls:'small-muted'}, 'No languages selected. Use controls to show at least one language.'));
      return;
    }
    const poss = root.querySelector(':scope > Possibilities, :scope > possibilities') || root;
    const topItems = Array.from(poss.children).filter(c=>c.nodeType === 1);
    const topUL = create('ul', {cls:'tree'});
    topItems.forEach(ti => topUL.appendChild(buildItem(ti, ordered)));
    listContainer.appendChild(topUL);
  }

  function buildItem(node, visibleLangs){
    const li = create('li');
    const sub = node.querySelector(':scope > SubPossibilities, :scope > SubPossibility, :scope > Possibilities');
    const hasSub = sub && Array.from(sub.children).some(c=>c.nodeType === 1);
    const toggle = create('span', {cls:'toggle'}, hasSub ? '▾' : ' ');
    if(hasSub) toggle.style.cursor = 'pointer';
    li.appendChild(toggle);

    const nameNode = node.querySelector(':scope > Name, :scope > name');
    const abbrNode = node.querySelector(':scope > Abbreviation, :scope > abbr');
    const names = collectAUniMap(nameNode);
    const abbrs = collectAUniMap(abbrNode);
    const inline = create('span');
    inline.innerHTML = buildMultilingualInlineHTML(names, abbrs, visibleLangs);
    li.appendChild(inline);

    if(hasSub){
      const ul = create('ul', {cls:'tree'});
      Array.from(sub.children).filter(c=>c.nodeType===1).forEach(ch => ul.appendChild(buildItem(ch, visibleLangs)));
      li.appendChild(ul);
      toggle.addEventListener('click', ()=> {
        li.classList.toggle('collapsed');
        toggle.textContent = toggle.textContent === '▾' ? '▸' : '▾';
      });
    }
    return li;
  }

  function swapOrder(ws, delta){
    const entries = Object.values(prefs).sort((a,b)=>a.order-b.order);
    const idx = entries.findIndex(e => e.ws === ws);
    const target = idx + delta;
    if(target < 0 || target >= entries.length) return;
    const a = entries[idx], b = entries[target];
    const t = a.order; a.order = b.order; b.order = t;
    saveJSON(LANG_PREFS_KEY, prefs); buildLangControls(); renderItems();
  }

  buildLangControls();
  renderItems();
  return container;
}

/* ===== Helpers for multilingual lists ===== */
function collectAUniMap(node){
  if(!node) return [];
  const a = Array.from(node.querySelectorAll('AUni'));
  if(a.length) return a.map(x => ({ ws: x.getAttribute('ws') || '', text: x.textContent.trim() }));
  // fallback: Name with ws attribute (mono) or plain text
  if(node.hasAttribute && node.hasAttribute('ws')) return [{ ws: node.getAttribute('ws') || '', text: (node.textContent || '').trim() }];
  const txt = (node.textContent || '').trim();
  return txt ? [{ ws:'', text: txt }] : [];
}

function buildMultilingualInlineHTML(names, abbrs, visibleLangs){
  if(!names || names.length === 0) return '(unnamed)';
  const shown = visibleLangs.map(ws => names.find(n => n.ws === ws)).filter(Boolean);
  if(!shown.length) return '(none)';
  const main = shown[0];
  const others = shown.slice(1);
  let html = `<span class="translation-main">${escapeHtml(main.text)}</span>`;
  if(others.length) html += ' ' + others.map(o => `<span class="translation-others">${escapeHtml(o.text)}</span>`).join(' · ');
  if(abbrs && abbrs.length){
    const abv = visibleLangs.map(ws => (abbrs.find(a => a.ws === ws) || {}).text).filter(Boolean);
    if(abv.length) html += ` <span class="small-muted">[${abv.map(escapeHtml).join(' / ')}]</span>`;
  }
  return html;
}

/* ===== Generic recursive fallback (unchanged) ===== */
function renderGenericView(root){
  const container = create('div');
  container.appendChild(create('div', {cls:'section-title'}, 'Generic XML View'));
  const rootUL = create('ul', {cls:'tree'});
  rootUL.appendChild(build(root));
  container.appendChild(rootUL);
  return container;

  function build(node){
    const li = create('li');
    const childElements = Array.from(node.childNodes).filter(n => n.nodeType === 1 || (n.nodeType === 3 && n.nodeValue.trim()));
    const hasChildren = childElements.length > 0;
    const toggle = create('span', {cls:'toggle'}, hasChildren ? '▾' : ' ');
    if(hasChildren) toggle.style.cursor='pointer';
    li.appendChild(toggle);

    const labelText = node.nodeType === 1 ? node.nodeName : '';
    const labelSpan = create('span');
    if(globalState.showNames && node.nodeType === 1) labelSpan.textContent = labelText + ': ';
    if(globalState.showNames && node.nodeType === 1) labelSpan.style.fontWeight = '600';
    li.appendChild(labelSpan);

    if(node.nodeType === 3){
      li.appendChild(document.createTextNode(node.nodeValue.trim()));
    } else {
      const textChild = Array.from(node.childNodes).filter(n=>n.nodeType===3 && n.nodeValue.trim())[0];
      if(textChild && childElements.every(n => n.nodeType === 3 || (n.nodeType === 1 && n.childNodes.length === 1 && n.childNodes[0].nodeType === 3))){
        li.appendChild(create('span', {}, textChild.nodeValue.trim()));
      } else {
        const subUL = create('ul', {cls:'tree'});
        childElements.forEach(ch => subUL.appendChild(build(ch)));
        li.appendChild(subUL);
        if(hasChildren){
          toggle.addEventListener('click', ()=> {
            li.classList.toggle('collapsed');
            toggle.textContent = toggle.textContent === '▾' ? '▸' : '▾';
          });
        }
      }
    }
    if(node.nodeType === 1) li.setAttribute('data-gen-label', node.nodeName);
    return li;
  }
}

/* ===== Phonology rendering (human-friendly) ===== */
function renderPhonologyView(xmlDoc){
  const root = xmlDoc.documentElement;
  const container = create('div');
  container.appendChild(create('div', {cls:'section-title'}, 'Phonology Summary'));
  container.appendChild(create('div', {cls:'small-muted'}, `Version ${root.getAttribute('Version') || '—'} — DefaultVernWs: ${root.getAttribute('DefaultVernWs') || '—'}`));

  // index phonemes
  globalState.phonemeIndex = {};
  const phonemes = Array.from(xmlDoc.getElementsByTagName('PhPhoneme') || []);
  phonemes.forEach(p => {
    const id = p.getAttribute('Id');
    const symbol = pickAUni(p.querySelector(':scope > Name')) || '';
    const desc = p.querySelector(':scope > Description Run')?.textContent?.trim() || '';
    const codes = Array.from(p.querySelectorAll(':scope > Codes PhCode Representation AUni')).map(a => a.textContent.trim()).filter(Boolean);
    globalState.phonemeIndex[id] = { id, symbol, desc, codes, node: p };
  });

  // phoneme sets / inventory
  const sets = Array.from(xmlDoc.getElementsByTagName('PhPhonemeSet') || []);
  sets.forEach(set => {
    const setName = pickAUni(set.querySelector(':scope > Name')) || 'Phoneme Set';
    const setDiv = create('div', {cls:'natclass'});
    setDiv.appendChild(create('div', {cls:'section-title'}, setName));
    const setDesc = set.querySelector(':scope > Description Run')?.textContent;
    if(setDesc) setDiv.appendChild(create('div', {cls:'small-muted'}, setDesc));

    const table = create('table', {cls:'phonemes'});
    table.innerHTML = '<thead><tr><th>Symbol</th><th>Description</th><th>ID</th><th>Codes</th></tr></thead>';
    const tbody = create('tbody');
    const rows = Array.from(set.querySelectorAll(':scope > Phonemes PhPhoneme')) || phonemes;
    rows.forEach(pnode => {
      const pid = pnode.getAttribute('Id');
      const data = globalState.phonemeIndex[pid] || {
        id: pid,
        symbol: pickAUni(pnode.querySelector(':scope > Name')) || '',
        desc: pnode.querySelector(':scope > Description Run')?.textContent || '',
        codes: Array.from(pnode.querySelectorAll(':scope > Codes PhCode Representation AUni')).map(a=>a.textContent.trim())
      };
      const row = create('tr', {id: 'phoneme-row-' + data.id});
      const symbolCell = create('td');
      const symBtn = create('span', {cls:'symbol-pill'}, data.symbol || '(no symbol)');
      symBtn.style.cursor = 'pointer';
      symBtn.addEventListener('click', ()=> onPhonemeSymbolClick(data.id));
      symbolCell.appendChild(symBtn);
      row.appendChild(symbolCell);
      row.appendChild(create('td', {}, data.desc || ''));
      row.appendChild(create('td', {}, data.id));
      row.appendChild(create('td', {}, (data.codes && data.codes.join(', ')) || ''));
      tbody.appendChild(row);
      globalState.phonemeRowIds[data.id] = row.id;
    });
    table.appendChild(tbody);
    setDiv.appendChild(table);

    // boundary markers
    const bMarkers = Array.from(set.querySelectorAll(':scope > BoundaryMarkers PhBdryMarker')) || [];
    if(bMarkers.length){
      setDiv.appendChild(create('div', {cls:'section-title'}, 'Boundary Markers'));
      const bmList = create('div', {cls:'small-muted'});
      bMarkers.forEach(bm => {
        const bmName = pickAUni(bm.querySelector(':scope > Name')) || bm.getAttribute('Id') || '';
        const bmCodes = Array.from(bm.querySelectorAll(':scope > Codes PhCode Representation AUni')).map(a=>a.textContent.trim()).filter(Boolean);
        bmList.appendChild(create('div', {}, `${bmName} ${ bmCodes.length ? '(' + bmCodes.join(', ') + ')' : ''}`));
      });
      setDiv.appendChild(bmList);
    }

    container.appendChild(setDiv);
  });

  // natural classes
  const ncs = Array.from(xmlDoc.getElementsByTagName('PhNCSegments') || []);
  if(ncs.length){
    container.appendChild(create('div', {cls:'section-title'}, 'Natural Classes'));
    ncs.forEach((nc, idx) => {
      const ncId = nc.getAttribute('Id') || ('nc-' + idx);
      const name = pickAUni(nc.querySelector(':scope > Name')) || nc.getAttribute('Id') || 'Unnamed';
      const abbr = pickAUni(nc.querySelector(':scope > Abbreviation')) || '';
      const desc = nc.querySelector(':scope > Description Run')?.textContent || '';
      const ncEl = create('div', {cls:'natclass', id: 'natclass-' + ncId});
      const title = create('div', {cls:'section-title'}, name + (abbr ? (' (' + abbr + ')') : ''));
      ncEl.appendChild(title);
      if(desc) ncEl.appendChild(create('div', {cls:'small-muted'}, desc));
      const segments = Array.from(nc.querySelectorAll(':scope > Segments')).map(s => s.getAttribute('dst')).filter(Boolean);
      const membersDiv = create('div', {cls:'members'});
      segments.forEach(sid => {
        const phon = globalState.phonemeIndex[sid];
        const text = phon ? (phon.symbol || phon.id) : sid;
        const pill = create('span', {cls:'symbol-pill'}, text);
        pill.addEventListener('click', ()=> {
          if(globalState.phonemeRowIds[sid]) scrollToAndHighlight(globalState.phonemeRowIds[sid]);
          else alert('Phoneme ID ' + sid + ' not found in phoneme index.');
        });
        membersDiv.appendChild(pill);
        if(!globalState.idToNatclassIds[sid]) globalState.idToNatclassIds[sid] = [];
        globalState.idToNatclassIds[sid].push(ncEl.id);
      });
      ncEl.appendChild(membersDiv);
      container.appendChild(ncEl);
      globalState.natclassElements[ncEl.id] = ncEl;
    });
  }

  // simple placeholders for Environments, Contexts, Rules
  const envs = Array.from(xmlDoc.getElementsByTagName('Environments') || []);
  envs.forEach(en => {
    const sec = create('div', {cls:'natclass'});
    sec.appendChild(create('div', {cls:'section-title'}, 'Environments'));
    sec.appendChild(en.hasChildNodes() ? renderGenericView(en) : create('div', {cls:'small-muted'}, '(no environment definitions)'));
    container.appendChild(sec);
  });
  const ctxs = Array.from(xmlDoc.getElementsByTagName('Contexts') || []);
  ctxs.forEach(c => {
    const sec = create('div', {cls:'natclass'});
    sec.appendChild(create('div', {cls:'section-title'}, 'Contexts'));
    sec.appendChild(c.hasChildNodes() ? renderGenericView(c) : create('div', {cls:'small-muted'}, '(no contexts defined)'));
    container.appendChild(sec);
  });

  // interactive behavior: clicking phoneme rows highlights natural classes
  Object.keys(globalState.phonemeRowIds).forEach(pid => {
    const rid = globalState.phonemeRowIds[pid];
    const row = document.getElementById(rid);
    if(row){
      row.addEventListener('click', ()=> {
        const natIds = globalState.idToNatclassIds[pid] || [];
        Object.values(globalState.natclassElements).forEach(el=> el.style.boxShadow = '');
        if(natIds.length){
          natIds.forEach(nid => {
            const el = globalState.natclassElements[nid];
            if(el){
              el.style.boxShadow = '0 0 0 3px rgba(11,110,219,0.08)';
              el.scrollIntoView({behavior:'smooth', block:'center'});
            }
          });
        } else {
          row.classList.add('highlight');
          setTimeout(()=> row.classList.remove('highlight'), 1200);
        }
      });
    }
  });

  return container;
}

/* ===== Wordforms export rendering (Card + Table + gloss language controls) ===== */
function renderWordformsView(xmlDoc){
  // root might be <wordforms> or something similar depending on export
  const root = xmlDoc.getElementsByTagName('wordforms')[0] || xmlDoc.documentElement;
  const container = create('div');
  container.appendChild(create('div', {cls:'section-title'}, 'Wordforms'));

  // collect all wordform nodes
  // FieldWorks samples may use <wordform> children
  const wfNodes = Array.from(root.getElementsByTagName('wordform'));
  // fallback: maybe root contains <Wordform> nodes
  if(wfNodes.length === 0){
    const alt = Array.from(root.getElementsByTagName('WordForm')).concat(Array.from(root.getElementsByTagName('Wordform')));
    if(alt.length) wfNodes.push(...alt);
  }

  // scan for gloss languages across all gloss elements
  const glossElems = Array.from(xmlDoc.querySelectorAll('gloss[ws], gloss AUni[ws], glosses gloss[ws]')) // flexible
    .concat(Array.from(xmlDoc.querySelectorAll('gloss'))); // fallback
  const glossLangsSet = new Set();
  glossElems.forEach(g => {
    if(g.getAttribute && g.getAttribute('ws')) glossLangsSet.add(g.getAttribute('ws'));
    else {
      // also accept <gloss><AUni ws="..."> or similar
      const auni = g.querySelector && g.querySelector('AUni[ws]');
      if(auni) glossLangsSet.add(auni.getAttribute('ws'));
    }
  });
  const glossLangs = Array.from(glossLangsSet);
  glossLangs.sort((a,b)=> a.toLowerCase().includes('en')? -1 : a.localeCompare(b));

  // load wordform prefs (view mode + gloss languages visibility)
  const saved = loadJSON(WORDFORM_PREFS_KEY) || {};
  let viewMode = saved.viewMode || 'card'; // 'card' or 'table'
  let glossPrefs = saved.glossPrefs || {};
  // init prefs from discovered glossLangs
  glossLangs.forEach((ws,i) => {
    if(typeof glossPrefs[ws] !== 'object') glossPrefs[ws] = { ws, visible: true, order: i };
  });

  // UI controls
  const controls = create('div', {cls:'controls-inline'});
  const viewToggle = create('button', {cls:'small-btn', title:'Toggle Card/Table view'}, viewMode === 'card' ? 'Switch to Table View 📋' : 'Switch to Card View 🗂️');
  controls.appendChild(viewToggle);

  // gloss language chooser (only shown in Table view)
  const glossChooser = create('div', {cls:'small-muted'});
  glossChooser.style.display = viewMode === 'table' ? 'block' : 'none';
  glossChooser.style.paddingLeft = '8px';
  glossChooser.style.marginLeft = '8px';
  glossChooser.textContent = 'Gloss languages: ';
  glossLangs.forEach(ws => {
    const label = create('label');
    label.style.marginRight = '8px';
    const cb = create('input'); cb.type = 'checkbox'; cb.checked = glossPrefs[ws].visible; cb.dataset.ws = ws;
    cb.addEventListener('change', () => {
      glossPrefs[ws].visible = cb.checked; saveJSON(WORDFORM_PREFS_KEY, { viewMode, glossPrefs }); renderItems();
    });
    label.appendChild(cb);
    label.appendChild(document.createTextNode(' ' + ws));
    glossChooser.appendChild(label);
  });

  controls.appendChild(glossChooser);
  container.appendChild(controls);

  // search/filter input (helpful)
  const searchRow = create('div', {cls:'small-muted'});
  searchRow.style.marginTop = '8px';
  searchRow.innerHTML = 'Filter: <input id="wf_search" placeholder="search form or gloss..." style="padding:4px;border-radius:4px;border:1px solid #ddd;margin-left:6px;">';
  container.appendChild(searchRow);

  const listArea = create('div');
  listArea.style.marginTop = '8px';
  container.appendChild(listArea);

  // wire view toggle
  viewToggle.addEventListener('click', ()=>{
    viewMode = viewMode === 'card' ? 'table' : 'card';
    saveJSON(WORDFORM_PREFS_KEY, { viewMode, glossPrefs });
    viewToggle.textContent = viewMode === 'card' ? 'Switch to Table View 📋' : 'Switch to Card View 🗂️';
    glossChooser.style.display = viewMode === 'table' ? 'block' : 'none';
    renderItems();
  });

  // render items either card or table
  function renderItems(){
    listArea.innerHTML = '';
    const q = (byId('wf_search')?.value || '').trim().toLowerCase();

    // helper to collect form text, glosses, category, counts
    function extractData(wf){
      const forms = [];
      // FieldWorks uses <form ws="..."> inside wordform — but samples vary. We'll be flexible.
      const formNodes = Array.from(wf.querySelectorAll('form, Form, word'));
      if(formNodes.length === 0){
        // try direct text
        const txt = (wf.textContent || '').trim();
        if(txt) forms.push({ws:'', text: txt});
      } else {
        formNodes.forEach(fn => {
          // look for AUni children if present
          const aunis = fn.querySelectorAll && fn.querySelectorAll('AUni');
          if(aunis && aunis.length){
            aunis.forEach(a => forms.push({ ws: a.getAttribute('ws') || '', text: (a.textContent||'').trim() }));
          } else {
            const ws = fn.getAttribute && fn.getAttribute('ws') || '';
            const t = (fn.textContent || '').trim();
            if(t) forms.push({ ws, text: t });
          }
        });
      }

      // analyses -> gloss, category, counts
      const analyses = Array.from(wf.querySelectorAll('analysis, Analysis'));
      const glosses = []; // array of {ws,text}
      const categories = [];
      analyses.forEach(a => {
        const gNodes = Array.from(a.querySelectorAll('gloss, Gloss'));
        if(gNodes.length){
          gNodes.forEach(gn => {
            const aun = gn.querySelector && gn.querySelector('AUni[ws]');
            if(aun) glosses.push({ ws: aun.getAttribute('ws') || '', text: (aun.textContent||'').trim() });
            else {
              const ws = gn.getAttribute && gn.getAttribute('ws') || '';
              const t = (gn.textContent || '').trim();
              if(t) glosses.push({ ws, text: t });
            }
          });
        }
        const cat = a.querySelector('category, Category')?.textContent?.trim();
        if(cat) categories.push(cat);
      });

      // counts
      const predicted = parseInt(wf.getAttribute('PredictedAnalyses') || wf.getAttribute('predictedanalyses') || wf.querySelector('PredictedAnalyses')?.textContent || '0') || 0;
      const user = parseInt(wf.getAttribute('UserAnalyses') || wf.getAttribute('useranalyses') || wf.querySelector('UserAnalyses')?.textContent || '0') || 0;

      return { forms, glosses, categories, predicted, user, node: wf };
    }

    const dataList = wfNodes.map(wf => extractData(wf));

    // apply search filter: matches form text or any gloss text
    const filtered = dataList.filter(d => {
      if(!q) return true;
      const formMatch = d.forms.some(f => (f.text||'').toLowerCase().includes(q));
      const glossMatch = d.glosses.some(g => (g.text||'').toLowerCase().includes(q));
      const catMatch = d.categories.some(c => (c||'').toLowerCase().includes(q));
      return formMatch || glossMatch || catMatch;
    });

    if(viewMode === 'card'){
      // Card view
      filtered.forEach(d => {
        const card = create('div', {cls:'wordform-card'});
        const header = create('div', {cls:'wordform-header'});
        const main = create('div');
        const primaryForm = d.forms[0]?.text || '(no form)';
        main.appendChild(create('div', {cls:'wordform-main'}, primaryForm));
        main.appendChild(create('div', {cls:'wordform-meta'}, `Predicted: ${d.predicted} · User: ${d.user}`));
        header.appendChild(main);
        // small expand button (collapse/expand body)
        const expBtn = create('button', {cls:'small-btn', title:'Toggle details'}, '▾');
        header.appendChild(expBtn);
        card.appendChild(header);

        const body = create('div', {cls:'wordform-body'});
        if(d.glosses.length === 0 && d.categories.length === 0){
          body.appendChild(create('div', {cls:'small-muted'}, '— No analysis —'));
        } else {
          // group glosses by ws
          const byWs = {};
          d.glosses.forEach(g => { if(!byWs[g.ws]) byWs[g.ws] = []; byWs[g.ws].push(g.text); });
          Object.keys(byWs).forEach(ws => {
            const line = create('div');
            line.innerHTML = `<strong>Gloss (${escapeHtml(ws)}):</strong> ${escapeHtml(byWs[ws].join('; '))}`;
            body.appendChild(line);
          });
          if(d.categories.length){
            body.appendChild(create('div', {}, `Category: ${escapeHtml(d.categories.join('; '))}`));
          }
        }
        body.style.display = 'block';
        expBtn.addEventListener('click', ()=> {
          body.style.display = body.style.display === 'none' ? 'block' : 'none';
          expBtn.textContent = expBtn.textContent === '▾' ? '▸' : '▾';
        });
        card.appendChild(body);
        listArea.appendChild(card);
      });
    } else {
      // Table view: show selected gloss columns based on glossPrefs
      const visibleGlossLangs = glossLangs.filter(ws => glossPrefs[ws] && glossPrefs[ws].visible);
      const table = create('table', {cls:'table-view'});
      // build header
      const thead = create('thead');
      const headerRow = create('tr');
      headerRow.appendChild(create('th', {}, 'Wordform'));
      visibleGlossLangs.forEach(ws => headerRow.appendChild(create('th', {}, `Gloss (${ws})`)));
      headerRow.appendChild(create('th', {}, 'Category'));
      headerRow.appendChild(create('th', {}, 'Pred'));
      headerRow.appendChild(create('th', {}, 'User'));
      thead.appendChild(headerRow);
      table.appendChild(thead);
      const tbody = create('tbody');
      filtered.forEach(d => {
        const tr = create('tr');
        const primaryForm = d.forms[0]?.text || '(no form)';
        tr.appendChild(create('td', {}, primaryForm));
        visibleGlossLangs.forEach(ws => {
          const text = d.glosses.filter(g=>g.ws === ws).map(g=>g.text).join('; ') || '—';
          tr.appendChild(create('td', {}, text));
        });
        tr.appendChild(create('td', {}, d.categories.join('; ') || '—'));
        tr.appendChild(create('td', {}, String(d.predicted)));
        tr.appendChild(create('td', {}, String(d.user)));
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      listArea.appendChild(table);
    }
  }

  // initial render
  renderItems();

  // wire search input
  const searchInput = byId('wf_search');
  if(searchInput){
    searchInput.addEventListener('input', () => { renderItems(); });
  }

  // wire gloss chooser UI to persist prefs
  // already wired by checkboxes earlier when created, but ensure persistence for viewMode state
  // save viewMode & glossPrefs whenever changed
  function persistWordformPrefs(){ saveJSON(WORDFORM_PREFS_KEY, { viewMode, glossPrefs }); }
  // update glossPrefs reference to the variable used by event handlers above
  // ensure glossPrefs is synced with UI checkbox states if user toggles view toggle
  // done through event handlers above that call saveJSON directly.

  return container;
}

/* ===== Utilities used by phonology rendering ===== */
function pickAUni(node){
  if(!node) return '';
  const aunis = Array.from(node.querySelectorAll('AUni'));
  if(aunis.length === 0) {
    const t = node.textContent && node.textContent.trim();
    return t || '';
  }
  for(const a of aunis){ const ws = (a.getAttribute('ws')||'').toLowerCase(); if(ws.includes('fau')) return a.textContent.trim(); }
  for(const a of aunis){ const ws = (a.getAttribute('ws')||'').toLowerCase(); if(ws.includes('en')) return a.textContent.trim(); }
  return aunis[0].textContent.trim();
}

/* ===== Click helpers ===== */
function onPhonemeSymbolClick(phonId){
  const rowId = globalState.phonemeRowIds[phonId];
  if(!rowId){ alert('Phoneme entry not found: ' + phonId); return; }
  scrollToAndHighlight(rowId);
}
function scrollToAndHighlight(rowId){
  const el = document.getElementById(rowId);
  if(!el) return;
  document.querySelectorAll('tr.highlight').forEach(r=> r.classList.remove('highlight'));
  el.classList.add('highlight');
  el.scrollIntoView({behavior:'smooth', block:'center'});
  el.classList.add('scroll-target');
  setTimeout(()=> el.classList.remove('scroll-target'), 2200);
}

/* ===== Build standalone HTML (for open/save) — note escaped closing tag to avoid template literal issues ===== */
function buildStandaloneHTML(opts){
  opts = opts || {};
  const render = byId('renderArea');
  // Gather prologue (if any) + current render content (without duplicating prologue)
  let content = '';
  const prologueNode = render.querySelector(':scope > .chart-prologue');
  const clone = render.cloneNode(true);
  // Remove in-app only controls from export snapshot
  try{ clone.querySelectorAll('.add-trans-btn, .add-band-btn').forEach(n=> n.remove()); }catch(e){ console.error('Error removing in-app buttons:', e); }
  // Remove interactive wiring attributes if any and re-render legend based on saved prefs post-prologue in export clone (legend already present in clone if rendered)
  // Helper: ensure destination table has individual <col> elements (no span)
  function ensureIndividualCols(tbl){
    const groups = Array.from(tbl.querySelectorAll('colgroup'));
    groups.forEach(g=>{
      const c = g.querySelector('col');
      if(!c) return;
      const span = Number(c.getAttribute('span')||'1');
      if(span > 1){
        c.removeAttribute('span');
        const frag = document.createDocumentFragment();
        for(let i=0;i<span;i++) frag.appendChild(document.createElement('col'));
        g.replaceChild(frag, c);
      }
    });
  }
  // Helper: freeze current column widths from live table into the cloned table
  function freezeChartColumnWidthsInClone(sourceRoot, cloneRoot){
    const srcTbl = sourceRoot.querySelector('table.chartshell');
    const dstTbl = cloneRoot.querySelector('table.chartshell');
    if(!srcTbl || !dstTbl) return;
    // Make sure destination has one <col> per column
    ensureIndividualCols(dstTbl);
    const dstCols = Array.from(dstTbl.querySelectorAll('col'));
    if(!dstCols.length) return;
    // Build widths array by measuring header (prefer title2), then fill from body rows as needed
    const widths = new Array(dstCols.length).fill(0);
    const srcHeader = srcTbl.querySelector('tr.row.title2') || srcTbl.querySelector('tr.row.title1');
    let colIndex = 0;
    if(srcHeader){
      srcHeader.querySelectorAll('th.cell').forEach(th=>{
        const span = Number(th.getAttribute('colspan')||'1');
        const w = Math.max(0, Math.round(th.getBoundingClientRect().width));
        const per = Math.max(0, Math.floor(w / span));
        for(let i=0;i<span && (colIndex + i) < widths.length;i++){
          widths[colIndex + i] = per;
        }
        colIndex += span;
      });
    }
    const srcBodyRows = Array.from(srcTbl.querySelectorAll('tbody tr'));
    function fillFromRow(row){
      let idx = 0;
      Array.from(row.children).forEach(td=>{
        const span = Number(td.getAttribute('colspan')||'1');
        const w = Math.max(0, Math.round(td.getBoundingClientRect().width));
        const per = Math.max(0, Math.floor(w / span));
        for(let i=0;i<span && (idx + i) < widths.length;i++){
          if(widths[idx + i] === 0) widths[idx + i] = per;
        }
        idx += span;
      });
    }
    if(widths.some(v=>v===0) && srcBodyRows.length){
      for(let r=0; r<Math.min(10, srcBodyRows.length); r++){
        fillFromRow(srcBodyRows[r]);
        if(!widths.some(v=>v===0)) break;
      }
    }
    // Apply a floor and assign to destination <col> style.width
    for(let i=0;i<widths.length;i++){
      const px = Math.max(40, widths[i] || 0);
      if(dstCols[i]) dstCols[i].style.width = px + 'px';
    }
    // Enforce fixed layout so widths render consistently in the export
    dstTbl.style.tableLayout = 'fixed';
    dstTbl.style.width = 'auto';
    dstTbl.style.maxWidth = '100%';
  }
  // Freeze widths before stripping interactive bits
  try{ freezeChartColumnWidthsInClone(render, clone); }catch(_){ /* non-fatal */ }
  // Keep column resizers in export so users can continue adjusting widths
  // Ensure destination table is marked as resizable for any styling hooks (optional)
  const dstTblForFlag = clone.querySelector('table.chartshell');
  if (dstTblForFlag) {
    dstTblForFlag.setAttribute('data-resizable', '1');
    // Drop compact print styling in exported snapshot; users can still toggle via CSS if desired
    dstTblForFlag.classList.remove('print-compact');
  }
  if(prologueNode){
    content += prologueNode.outerHTML; // put prologue first
    const cPrologue = clone.querySelector(':scope > .chart-prologue');
    if(cPrologue) cPrologue.remove(); // remove from rest of content
  }
  content += clone.innerHTML;

  // Epilogue content (appears after everything else in export)
  try{
    const postPrefs = loadJSON(TEXTCHART_POSTLOGUE_KEY) || {};
    let postHtml = postPrefs.html || '';
    const auto = typeof postPrefs.autoConvert === 'boolean' ? postPrefs.autoConvert : true;
    if(postHtml && postHtml.trim()){
      const appearsHtml = /<\s*[a-zA-Z!/]/.test(postHtml);
      if(auto && !appearsHtml){
        const norm = postHtml.replace(/\r\n?/g, '\n');
        const paras = norm.split(/\n{2,}/).map(s=>s.trim()).filter(Boolean);
        postHtml = paras.map(p => `<p>${escapeHtml(p).replace(/\n/g, '<br />')}</p>`).join('\n');
      }
      content += `\n<div class="chart-epilogue">${postHtml}</div>`;
    }
  }catch(_){/* ignore */}

  // Pick a title for the export: prefer H1 from prologue, then any heading/div/p, else fallback
  let exportTitle = 'FLEx XML View Export';
  if (prologueNode) {
    const h1 = prologueNode.querySelector('h1');
    const anyHead = prologueNode.querySelector('h1,h2,h3,h4,h5,h6,div,p');
    const titleNode = h1 || anyHead;
    if (titleNode && titleNode.textContent) {
      const t = titleNode.textContent.replace(/\s+/g, ' ').trim();
      if (t) exportTitle = t;
    }
  }
  // Collect all current styles from <head> including any injected at runtime
  function collectCurrentHeadCSS(){
    let css = '';
    // Inline <style> tags in order
    document.head.querySelectorAll('style').forEach((s, idx)=>{
      const label = s.id ? `style#${s.id}` : `style[${idx}]`;
      const txt = s.textContent || '';
      if(txt) css += `\n/* ${label} */\n` + txt + '\n';
    });
    // Attempt to inline same-origin linked stylesheets (unchanged; include all rules)
    Array.from(document.styleSheets || []).forEach(ss => {
      try{
        if(ss && ss.ownerNode && ss.ownerNode.tagName === 'LINK' && ss.cssRules){
          css += `\n/* linked stylesheet: ${ss.href || ''} */\n`;
          for(const rule of ss.cssRules){ css += rule.cssText + '\n'; }
        }
      }catch(e){ /* likely a cross-origin stylesheet; skip */ }
    });
    return css.trim();
  }
  const headCSS = collectCurrentHeadCSS();
  const savedFreeze = loadJSON(FREEZE_HEADERS_KEY);
  const freezeEnabled = !!(savedFreeze && savedFreeze.enabled);
  // Free translation inline style variables for export
  let ftVarsCSS = '';
  try{
    const ftp = loadJSON(FT_PREFS_KEY) || {};
    const st = ftp.style || {};
    const vars = [];
    if(st.fontSize) vars.push(`--ft-inline-font-size: ${st.fontSize}`);
    if(st.color) vars.push(`--ft-inline-color: ${st.color}`);
    if(st.bg) vars.push(`--ft-inline-bg: ${st.bg}`);
    if(vars.length){ ftVarsCSS = `:root{ ${vars.join('; ')}; }`; }
  }catch(e){ console.error(e); }
  // Add minimal sticky header CSS to ensure freeze works even if outer CSS is pruned
  const stickyCSS = `
  .chartshell.freeze-headers thead tr.row.title1 th,
  .chartshell.freeze-headers thead tr.row.title2 th{position:sticky;z-index:3;background:#fff}
  .chartshell.freeze-headers thead tr.row.title1 th{top:var(--tc-sticky-top-1,0px)}
  .chartshell.freeze-headers thead tr.row.title2 th{top:var(--tc-sticky-top-2,32px);z-index:4}
  .chartshell-sticky-spacer{height:var(--tc-sticky-spacer,0px)}
  `;
  // Optional export toolbar markup
  const exportToolbar = opts.includeToolbar ? (
    '<div class="export-toolbar" role="region" aria-label="Export toolbar" style="position:sticky;top:0;z-index:1000;background:#f7faff;border-bottom:1px solid #dbe7ff;padding:8px 10px;display:flex;gap:8px;align-items:center;box-shadow:0 1px 0 rgba(0,0,0,0.03)">\
      <button id="exportSaveBtn" style="background:#0b6edb;color:#fff;border:none;padding:6px 10px;border-radius:6px;cursor:pointer">Save Chart As… (HTML)</button>\
      <button id="exportPrintBtn" style="background:#ddd;color:#111;border:none;padding:6px 10px;border-radius:6px;cursor:pointer">Print / Export to PDF</button>\
      <div class="small-muted" style="margin-left:auto;color:#666">Toolbar is not printed</div>\
    </div>'
  ) : '';
  const doc = `<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>${escapeHtml(exportTitle)}</title>
${freezeEnabled ? '<meta name="flex-freeze-headers" content="1" />' : ''}
<style>${headCSS}\n${stickyCSS}
/* Hide export toolbar in print */
@media print { .export-toolbar { display: none !important; } }
${ftVarsCSS}
</style>
</head>
<body>
${exportToolbar}
${content}
<script>
  // Persisted freeze headers behavior from source document
  (function(){
    function computeStickyOffsets(){
      const tbl = document.querySelector('table.chartshell');
      if(!tbl) return;
      const head = tbl.querySelector('thead');
      const r1 = head?.querySelector('tr.row.title1');
      const r2 = head?.querySelector('tr.row.title2');
      const rect1 = r1?.getBoundingClientRect();
      const rect2 = r2?.getBoundingClientRect();
      // Offset by export toolbar height so sticky headers stay below it
      const toolbar = document.querySelector('.export-toolbar');
      const topBase = toolbar ? Math.ceil(toolbar.getBoundingClientRect().height || 0) : 0;
      const h1 = rect1 ? Math.ceil(rect1.height) : 0;
      const h2 = rect2 ? Math.ceil(rect2.height) : 0;
      document.documentElement.style.setProperty('--tc-sticky-top-1', topBase + 'px');
      document.documentElement.style.setProperty('--tc-sticky-top-2', (topBase + h1) + 'px');
      document.documentElement.style.setProperty('--tc-sticky-spacer', (h1 + h2) + 'px');
    }
    function applyFreezeHeaders(){
      const tbl = document.querySelector('table.chartshell');
      if(!tbl) return;
      tbl.classList.add('freeze-headers');
      const wrapper = tbl.closest('.chartshell-wrapper') || tbl.parentElement;
      let spacer = wrapper?.querySelector(':scope > .chartshell-sticky-spacer');
      if(!spacer){ spacer = document.createElement('div'); spacer.className = 'chartshell-sticky-spacer'; if(wrapper) wrapper.insertBefore(spacer, tbl); else tbl.parentElement?.insertBefore(spacer, tbl); }
      computeStickyOffsets();
  window.addEventListener('resize', computeStickyOffsets);
  window.addEventListener('scroll', computeStickyOffsets, true);
    }
    // Read preference from embedded data attribute if present
    const root = document.documentElement;
    const shouldFreeze = (function(){
      try{
        const meta = document.querySelector('meta[name="flex-freeze-headers"]');
        return meta && meta.getAttribute('content') === '1';
      }catch(_){ return false; }
    })();
    if(shouldFreeze){
      if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', applyFreezeHeaders);
      else applyFreezeHeaders();
      // One more pass after load to account for toolbar height
      window.addEventListener('load', computeStickyOffsets);
      setTimeout(computeStickyOffsets, 50);
      setTimeout(computeStickyOffsets, 200);
    }
  })();
  document.querySelectorAll('.toggle').forEach(t=> {
    const parent = t.parentElement;
    t.addEventListener('click', ()=> {
      parent.classList.toggle('collapsed');
      t.textContent = t.textContent === '▾' ? '▸' : '▾';
    });
  });
  document.querySelectorAll('.symbol-pill').forEach(p=> {
    p.addEventListener('click', ()=> {
      const txt = p.textContent.trim();
      const rows = document.querySelectorAll('table.phonemes tbody tr');
      for(const r of rows){
        if(r.cells[0] && r.cells[0].textContent.trim() === txt){
          r.scrollIntoView({behavior:'smooth', block:'center'});
          r.classList.add('highlight');
          setTimeout(()=> r.classList.remove('highlight'), 1800);
          return;
        }
      }
    });
  });
  // Re-enable column resizing for Text Chart in exported document
  (function(){
    function wireHandleDrag(handle, allCols){
      let startX = 0, startWidth = 0, colEl = null;
      function computeMinColWidth(tbl, idx){
        let minW = 40;
        const rows = Array.from(tbl.querySelectorAll('tbody tr')).slice(0, 200);
        rows.forEach(row=>{
          let ci = 0; let cell = null;
          Array.from(row.children).some(td=>{
            const sp = Number(td.getAttribute('colspan')||'1');
            const covers = (idx >= ci) && (idx < ci + sp);
            ci += sp; if(covers){ cell = td; return true; } return false;
          });
          if(cell){
            let pairs = cell.querySelectorAll('.interlinear .pair:not(.note)');
            if(!pairs.length) pairs = cell.querySelectorAll('.interlinear .pair');
            pairs.forEach(p=>{ const w = Math.ceil(p.getBoundingClientRect().width); if(w > minW) minW = w; });
          }
        });
        return Math.max(40, minW);
      }
      function onMove(e){
        const dx = e.clientX - startX;
        const tbl = handle.closest('table');
        const idx = Number(handle.dataset.colEnd||'0');
        const minAllowed = computeMinColWidth(tbl, idx);
        const newW = Math.max(minAllowed, startWidth + dx);
        colEl.style.width = newW + 'px';
        handle.classList.add('dragging');
      }
      function onUp(){
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
        handle.classList.remove('dragging');
      }
      handle.addEventListener('mousedown', (e)=>{
        e.preventDefault();
        const idx = Number(handle.dataset.colEnd||'0');
        colEl = allCols[idx];
        if(!colEl) return;
        const tbl = handle.closest('table');
        const bodyRow = tbl.querySelector('tbody tr');
        let probeCell = null;
        if(bodyRow){
          let ci = 0; probeCell = Array.from(bodyRow.children).find(td=>{
            const sp = Number(td.getAttribute('colspan')||'1');
            const covers = (idx >= ci) && (idx < ci + sp);
            ci += sp; return covers;
          });
        }
        const rect = (probeCell || handle.parentElement).getBoundingClientRect();
        if(!colEl.style.width){ colEl.style.width = Math.max(40, Math.round(rect.width)) + 'px'; }
        startX = e.clientX;
        startWidth = parseFloat(colEl.style.width) || Math.max(40, Math.round(rect.width));
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
      });
    }
    function initExportResizing(){
      const tbl = document.querySelector('table.chartshell');
      if(!tbl) return;
      // Ensure fixed layout and individual cols
      tbl.style.tableLayout = 'fixed';
      tbl.style.width = 'auto';
      tbl.style.maxWidth = '100%';
      const groups = Array.from(tbl.querySelectorAll('colgroup'));
      const allCols = groups.flatMap(g => Array.from(g.querySelectorAll('col')));
      // Re-wire existing handles
      tbl.querySelectorAll('.col-resizer').forEach(h => wireHandleDrag(h, allCols));
      tbl.setAttribute('data-resizable', '1');
    }
    if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initExportResizing);
    else initExportResizing();
  })();
  // Endnote HTML tooltip wiring (exported doc)
  (function(){
    let tipEl = null; let hideTimer = null;
    function ensureTip(){ if(!tipEl){ tipEl = document.createElement('div'); tipEl.className = 'note-tooltip'; const arrow = document.createElement('div'); arrow.className='arrow'; tipEl.appendChild(arrow); document.body.appendChild(tipEl); } return tipEl; }
    function setTipContent(html){ const arrow = tipEl.querySelector('.arrow'); tipEl.innerHTML=''; tipEl.appendChild(arrow); const box = document.createElement('div'); box.innerHTML = html; tipEl.appendChild(box); }
    function positionTipFor(target, evt){
      const rect = target.getBoundingClientRect();
      const margin = 8; const arrow = tipEl.querySelector('.arrow');
      tipEl.style.visibility='hidden'; tipEl.style.display='block';
      const vw = window.innerWidth, vh = window.innerHeight;
      const tipW = Math.min(400, tipEl.offsetWidth || 0), tipH = tipEl.offsetHeight || 0;
      let top = rect.bottom + margin; let left = rect.left;
      if(evt && typeof evt.clientX==='number'){ left = evt.clientX + 12; }
      if(top + tipH > vh - margin){ top = Math.max(margin, rect.top - tipH - margin); }
      left = Math.max(margin, Math.min(left, vw - tipW - margin));
  tipEl.style.top = Math.round(top) + 'px';
  tipEl.style.left = Math.round(left) + 'px';
  const aSize = 10; arrow.style.width = aSize + 'px'; arrow.style.height = aSize + 'px';
  const arrowTop = (top >= rect.bottom) ? (tipEl.offsetHeight - 1) : (-aSize/2);
  arrow.style.top = arrowTop + 'px';
  const centerX = rect.left + rect.width/2; const ax = Math.max(aSize, Math.min(centerX - left - aSize/2, tipW - 2*aSize));
  arrow.style.left = ax + 'px';
      tipEl.style.visibility='visible';
    }
    function showTip(link, evt){
      clearTimeout(hideTimer);
      const contentEl = (link.parentElement && (link.parentElement.querySelector('.note-tooltip-content') || link.parentElement.querySelector('.ft-tooltip-content')));
      if(!contentEl) return;
      ensureTip(); setTipContent(contentEl.innerHTML); positionTipFor(link, evt);
    }
    function scheduleHide(){ clearTimeout(hideTimer); hideTimer = setTimeout(()=>{ if(tipEl) tipEl.style.display='none'; }, 200); }
    function cancelHide(){ clearTimeout(hideTimer); }
    function wire(){
      const links = Array.from(document.querySelectorAll('.note-link, .ft-link'));
      links.forEach(l=>{
        l.addEventListener('mouseenter', (e)=>{ cancelHide(); showTip(l, e); });
        l.addEventListener('mousemove', (e)=>{ if(tipEl && tipEl.style.display!=='none'){ positionTipFor(l, e); } });
        l.addEventListener('mouseleave', scheduleHide);
        l.addEventListener('focus', (e)=>{ cancelHide(); showTip(l, e); });
        l.addEventListener('blur', scheduleHide);
      });
      document.addEventListener('scroll', ()=>{ if(tipEl) tipEl.style.display='none'; }, true);
      window.addEventListener('resize', ()=>{ if(tipEl){ tipEl.style.display='none'; } });
    }
    if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', wire);
    else wire();
  })();
  // Export toolbar handlers (save and print)
  (function(){
    function suggestExportFilename(){
      try{
        var titleNode = document.querySelector('.chart-prologue h1, .chart-prologue h2, .chart-prologue h3, .chart-prologue div, .chart-prologue p');
        var t = (titleNode && titleNode.textContent || '').trim().replace(/\s+/g,' ');
        var base = t || 'FLEx XML View Export — Text Chart';
        var name = base.replace(/[\\/:*?"<>|]+/g, ' ').replace(/\s+/g,' ').trim();
        if(!/\.html?$/i.test(name)) name += '.html';
        return name;
      }catch(_){ return 'FLEx XML View Export — Text Chart.html'; }
    }
    function saveAsHtml(){
      try{
        var html = document.documentElement.outerHTML;
        var filename = suggestExportFilename();
        if(window.showSaveFilePicker){
          (async function(){
            try{
              const handle = await window.showSaveFilePicker({ suggestedName: filename, types: [{ description: 'HTML Document', accept: { 'text/html': ['.html', '.htm'] } }] });
              const writable = await handle.createWritable();
              await writable.write(new Blob([html], {type:'text/html'}));
              await writable.close();
            }catch(err){ if(!(err && err.name==='AbortError')) fallbackDownload(html, filename); }
          })();
        } else {
          fallbackDownload(html, filename);
        }
      }catch(e){ console.warn('Error applying FT inline style variables:', e); }
    }
    function fallbackDownload(html, filename){
      var blob = new Blob([html], {type:'text/html'});
      var a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click(); URL.revokeObjectURL(a.href);
    }
    function printNow(){ try{ window.focus(); window.print(); }catch(_){ /* ignore */ } }
    var saveBtn = document.getElementById('exportSaveBtn'); if(saveBtn) saveBtn.addEventListener('click', saveAsHtml);
    var printBtn = document.getElementById('exportPrintBtn'); if(printBtn) printBtn.addEventListener('click', printNow);
  })();
<\/script>
</body>
</html>`;
  return doc;
}

/* ===== Column resizing for Text Chart in-app ===== */
function expandColgroupsToIndividualCols(tbl){
  const groups = Array.from(tbl.querySelectorAll('colgroup'));
  groups.forEach(g=>{
    const c = g.querySelector('col');
    if(!c) return;
    const span = Number(c.getAttribute('span')||'1');
    if(span > 1){
      c.removeAttribute('span');
      const frag = document.createDocumentFragment();
      for(let i=0;i<span;i++) frag.appendChild(document.createElement('col'));
      g.replaceChild(frag, c);
    }
  });
}
function addResizeHandles(tbl){
  const header2 = tbl.querySelector('tr.row.title2');
  const header = header2 || tbl.querySelector('tr.row.title1');
  if(!header) return;
  let colIndex = 0;
  const groups = Array.from(tbl.querySelectorAll('colgroup'));
  const allCols = groups.flatMap(g => Array.from(g.querySelectorAll('col')));
  header.querySelectorAll('th.cell').forEach(th=>{
    const span = Number(th.getAttribute('colspan')||'1');
    const targetColEnd = colIndex + span - 1;
    const handle = document.createElement('div');
    handle.className = 'col-resizer';
    handle.title = 'Drag to resize column';
    handle.dataset.colEnd = String(targetColEnd);
    th.appendChild(handle);
    wireHandleDrag(handle, allCols);
    colIndex += span;
  });
}
function wireHandleDrag(handle, allCols){
  let startX = 0, startWidth = 0, colEl = null;
    function computeMinColWidth(tbl, idx){
      let minW = 40;
      const rows = Array.from(tbl.querySelectorAll('tbody tr')).slice(0, 200);
      rows.forEach(row=>{
        let ci = 0; let cell = null;
        Array.from(row.children).some(td=>{
          const sp = Number(td.getAttribute('colspan')||'1');
          const covers = (idx >= ci) && (idx < ci + sp);
          ci += sp; if(covers){ cell = td; return true; } return false;
        });
        if(cell){
          let pairs = cell.querySelectorAll('.interlinear .pair:not(.note)');
          if(!pairs.length) pairs = cell.querySelectorAll('.interlinear .pair');
          pairs.forEach(p=>{ const w = Math.ceil(p.getBoundingClientRect().width); if(w > minW) minW = w; });
        }
      });
      return Math.max(40, minW);
    }
  function onMove(e){
    const dx = e.clientX - startX;
      const tbl = handle.closest('table');
      const idx = Number(handle.dataset.colEnd||'0');
      const minAllowed = computeMinColWidth(tbl, idx);
      const newW = Math.max(minAllowed, startWidth + dx);
    colEl.style.width = newW + 'px';
    handle.classList.add('dragging');
  }
  function onUp(){
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    handle.classList.remove('dragging');
  }
  handle.addEventListener('mousedown', (e)=>{
    e.preventDefault();
    const idx = Number(handle.dataset.colEnd||'0');
    colEl = allCols[idx];
    if(!colEl) return;
    const tbl = handle.closest('table');
    const bodyRow = tbl.querySelector('tbody tr');
    let probeCell = null;
    if(bodyRow){
      let ci = 0; probeCell = Array.from(bodyRow.children).find(td=>{
        const sp = Number(td.getAttribute('colspan')||'1');
        const covers = (idx >= ci) && (idx < ci + sp);
        ci += sp; return covers;
      });
    }
    const rect = (probeCell || handle.parentElement).getBoundingClientRect();
    if(!colEl.style.width){ colEl.style.width = Math.max(40, Math.round(rect.width)) + 'px'; }
    startX = e.clientX;
    startWidth = parseFloat(colEl.style.width) || Math.max(40, Math.round(rect.width));
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });
}
function enableTextChartColumnResize(root){
  const tbl = (root instanceof Element ? root : document).querySelector('table.chartshell');
  if(!tbl || tbl.dataset.resizable === '1') return;
  expandColgroupsToIndividualCols(tbl);
  addResizeHandles(tbl);
  tbl.dataset.resizable = '1';
    tbl.style.tableLayout = 'fixed';
    tbl.style.width = 'auto';
    tbl.style.maxWidth = '100%';
}

/* ===== Endnote tooltip (HTML) ===== */
(function(){
  let tipEl = null; let hideTimer = null;
  function ensureTip(){ if(!tipEl){ tipEl = document.createElement('div'); tipEl.className = 'note-tooltip'; const arrow = document.createElement('div'); arrow.className='arrow'; tipEl.appendChild(arrow); document.body.appendChild(tipEl); } return tipEl; }
  function setTipContent(html){ const arrow = tipEl.querySelector('.arrow'); tipEl.innerHTML=''; tipEl.appendChild(arrow); const box = document.createElement('div'); box.innerHTML = html; tipEl.appendChild(box); }
  function positionTipFor(target, evt){
    const rect = target.getBoundingClientRect();
    const margin = 8; const arrow = tipEl.querySelector('.arrow');
    tipEl.style.visibility='hidden'; tipEl.style.display='block';
    const vw = window.innerWidth, vh = window.innerHeight;
    const tipW = Math.min(400, tipEl.offsetWidth || 0), tipH = tipEl.offsetHeight || 0;
    let top = rect.bottom + margin; let left = rect.left;
    if(evt && typeof evt.clientX==='number'){ left = evt.clientX + 12; }
    // if overflow bottom, place above
    if(top + tipH > vh - margin){ top = Math.max(margin, rect.top - tipH - margin); }
    // clamp horizontally
    left = Math.max(margin, Math.min(left, vw - tipW - margin));
    tipEl.style.top = `${Math.round(top)}px`;
    tipEl.style.left = `${Math.round(left)}px`;
    // arrow placement
    const aSize = 10; arrow.style.width=`${aSize}px`; arrow.style.height=`${aSize}px`;
    const arrowTop = (top >= rect.bottom) ? (tipEl.offsetHeight - 1) : (-aSize/2);
    arrow.style.top = `${arrowTop}px`;
    const centerX = rect.left + rect.width/2; const ax = Math.max(aSize, Math.min(centerX - left - aSize/2, tipW - 2*aSize));
    arrow.style.left = `${ax}px`;
    tipEl.style.visibility='visible';
  }
  function showTip(link, evt){
    clearTimeout(hideTimer);
    const contentEl = link.parentElement?.querySelector('.note-tooltip-content') || link.parentElement?.querySelector('.ft-tooltip-content');
    if(!contentEl) return;
    const html = contentEl.innerHTML;
    ensureTip(); setTipContent(html); positionTipFor(link, evt);
  }
  function scheduleHide(){ clearTimeout(hideTimer); hideTimer = setTimeout(()=>{ if(tipEl) tipEl.style.display='none'; }, 200); }
  function cancelHide(){ clearTimeout(hideTimer); }
  function wire(container){
    const links = Array.from(container.querySelectorAll('.note-link, .ft-link'));
    links.forEach(l=>{
      l.addEventListener('mouseenter', (e)=>{ cancelHide(); showTip(l, e); });
      l.addEventListener('mouseleave', scheduleHide);
      l.addEventListener('mousemove', (e)=>{ if(tipEl && tipEl.style.display!=='none'){ positionTipFor(l, e); } });
      l.addEventListener('focus', (e)=>{ cancelHide(); showTip(l, e); });
      l.addEventListener('blur', scheduleHide);
    });
    if(!container.dataset.noteTooltipGlobal){
      document.addEventListener('scroll', ()=>{ if(tipEl) tipEl.style.display='none'; }, true);
      window.addEventListener('resize', ()=>{ if(tipEl){ tipEl.style.display='none'; } });
      container.dataset.noteTooltipGlobal = '1';
    }
  }
  // Wire after each render
  function wireNow(){ try{ wire(document.getElementById('renderArea')); }catch(_){} }
  // Expose global hook to wire tooltips after DOM updates
  window.wireNoteTooltips = wireNow;
  const origRenderDocument = window.renderDocument;
  if(typeof origRenderDocument === 'function'){
    window.renderDocument = async function(xml){ const r = await origRenderDocument(xml); wireNow(); return r; };
  }
  // Also wire on initial load and after text chart render completes from renderDocument flow
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', wireNow);
  else wireNow();
})();

/* ===== Free translations feature ===== */
function showFTPanel(show){ const p = byId('ftPanel'); if(p) p.style.display = show ? 'block' : 'none'; }
function initFTControls(){
  const panel = byId('ftPanel'); if(!panel) return;
  const modeSel = byId('ftMode'); const clearAll = byId('ftClearAll');
  const fontSizeIn = byId('ftFontSize'); const colorIn = byId('ftColor'); const bgIn = byId('ftBg');
  const prefs = loadFTPrefs();
  if(modeSel) modeSel.value = prefs.mode || 'tooltip';
  if(fontSizeIn) fontSizeIn.value = prefs.style?.fontSize || '';
  if(colorIn) colorIn.value = prefs.style?.color || '#333333';
  if(bgIn) bgIn.value = prefs.style?.bg || '#fbfcff';
  function onModeChange(){ const p = loadFTPrefs(); p.mode = modeSel.value; saveFTPrefs(p); const area = byId('renderArea'); applyFreeTranslationsToArea(area); }
  modeSel?.addEventListener('change', onModeChange);
  function onStyleChange(){
    const p = loadFTPrefs(); p.style = p.style || {};
    p.style.fontSize = (fontSizeIn?.value || '').trim();
    p.style.color = (colorIn?.value || '').trim();
    p.style.bg = (bgIn?.value || '').trim();
    // cleanup empties
    if(!p.style.fontSize) delete p.style.fontSize;
    if(!p.style.color) delete p.style.color;
    if(!p.style.bg) delete p.style.bg;
    saveFTPrefs(p);
    const area = byId('renderArea'); applyFreeTranslationsToArea(area);
  }
  fontSizeIn?.addEventListener('change', onStyleChange);
  colorIn?.addEventListener('input', onStyleChange);
  bgIn?.addEventListener('input', onStyleChange);
  clearAll?.addEventListener('click', ()=>{
    if(!confirm('Clear all free translations for this chart?')) return;
    const p = loadFTPrefs(); p.items = {}; saveFTPrefs(p);
    const area = byId('renderArea'); applyFreeTranslationsToArea(area); wireFreeTranslationButtons(area);
  });
}
function computeRowLabelFromRow(tr){
  try{
    const rn = tr?.querySelector('td .interlinear .pair .w.rownum');
    const t = rn?.textContent?.trim();
    if(t) return t;
  }catch(e){ console.error('Error computing row label from row:', e); }
  // fallback: sequence number among body rows (1-based)
  try{
    const all = Array.from(tr.parentElement?.querySelectorAll(':scope > tr') || []).filter(r=> !r.classList.contains('title1') && !r.classList.contains('title2') && !r.classList.contains('ft-inline'));
    const idx = all.indexOf(tr);
    return String(idx + 1);
  }catch(e){ console.error('Error in computeRowLabelFromRow:', e); return ''; }
}
function computeTotalColumns(tbl){
  const colCount = tbl.querySelectorAll('colgroup col').length;
  if(colCount > 0) return colCount;
  const ths = tbl.querySelectorAll('thead tr.row.title1 th');
  if(ths && ths.length){ let sum = 0; ths.forEach(th=>{ sum += Number(th.getAttribute('colspan')||'1'); }); return sum; }
  // fallback: count cells in first body row
  const r = tbl.querySelector('tbody tr'); if(r){ let sum=0; r.querySelectorAll(':scope > *').forEach(c=> sum += Number(c.getAttribute('colspan')||'1')); return sum; }
  return 1;
}
function wireFreeTranslationButtons(area){
  const tbl = area?.querySelector('table.chartshell'); if(!tbl) return;
  // Remove any existing buttons first
  tbl.querySelectorAll('.add-trans-btn').forEach(b=> b.remove());
  const prefs = loadFTPrefs(); const items = prefs.items || {};
  Array.from(tbl.querySelectorAll('tbody tr')).forEach(tr=>{
    if(tr.classList.contains('title1') || tr.classList.contains('title2') || tr.classList.contains('ft-inline')) return;
    const firstCell = tr.querySelector('td'); if(!firstCell) return;
    const rownumSpan = firstCell.querySelector('.interlinear .pair .w.rownum');
    if(!rownumSpan) return;
  const label = computeRowLabelFromRow(tr);
    const btn = document.createElement('button');
    btn.type='button'; btn.className='add-trans-btn'; btn.textContent = items[label] ? 'Edit trans…' : 'Add trans…';
    btn.title = 'Add or edit free translation for this row';
    btn.addEventListener('click', async ()=>{
  const pcur = loadFTPrefs();
  const current = (pcur.items||{})[label] || '';
      const next = await showFTEditor('Free translation — row ' + label, current);
      if(next === null) return; // cancelled
  const p = loadFTPrefs(); p.items = p.items || {}; const val = (next||'').trim();
  if(val){ p.items[label] = val; } else { delete p.items[label]; }
      saveFTPrefs(p);
      btn.textContent = (val ? 'Edit trans…' : 'Add trans…');
      applyFreeTranslationsToArea(area);
    });
    rownumSpan.parentElement?.appendChild(btn);
  });
}

// Simple modal text editor used for Free Translations
function showFTEditor(title, initial){
  return new Promise(resolve=>{
    const overlay = document.createElement('div'); overlay.className='modal-overlay';
    const modal = document.createElement('div'); modal.className='modal'; overlay.appendChild(modal);
    const h = document.createElement('h3'); h.textContent = title || 'Free translation'; modal.appendChild(h);
    const ta = document.createElement('textarea'); ta.value = initial || ''; modal.appendChild(ta);
    const actions = document.createElement('div'); actions.className='modal-actions'; modal.appendChild(actions);
    const cancel = document.createElement('button'); cancel.className='secondary'; cancel.textContent='Cancel';
    const save = document.createElement('button'); save.textContent='Save';
    actions.appendChild(cancel); actions.appendChild(save);
    function done(val){ document.body.removeChild(overlay); resolve(val); }
    cancel.addEventListener('click', ()=> done(null));
    save.addEventListener('click', ()=> done(ta.value));
    overlay.addEventListener('click', (e)=>{ if(e.target === overlay) done(null); });
    ta.addEventListener('keydown', (e)=>{ if(e.key==='Escape') done(null); if((e.metaKey||e.ctrlKey)&&e.key==='Enter') done(ta.value); });
    document.body.appendChild(overlay); ta.focus(); ta.select();
  });
}
function clearExistingFTArtifacts(area){
  if(!area) area = byId('renderArea'); if(!area) return;
  // Remove inline rows
  area.querySelectorAll('tr.ft-inline').forEach(r=> r.remove());
  // Remove link markers and tooltip content
  area.querySelectorAll('.ft-link').forEach(a=>{ const p=a.parentElement; const sib = p?.querySelector('.ft-tooltip-content'); a.remove(); if(sib) sib.remove(); });
  // Remove appended section
  area.querySelectorAll(':scope > .chart-freetrans').forEach(n=> n.remove());
}
function applyFT_TooltipMode(area, tbl, items){
  // Insert link markers by row number
  Array.from(tbl.querySelectorAll('tbody tr')).forEach(tr=>{
    if(tr.classList.contains('title1') || tr.classList.contains('title2') || tr.classList.contains('ft-inline')) return;
    const label = computeRowLabelFromRow(tr); const text = items[label]; if(!text) return;
    const firstCell = tr.querySelector('td'); if(!firstCell) return;
  const rownumSpan = firstCell.querySelector('.interlinear .pair .w.rownum'); if(!rownumSpan) return;
  // ensure a stable back-link anchor on the row number
  if(!rownumSpan.id) rownumSpan.id = 'row-' + label + '-ftsrc';
    // avoid duplicates
    if(rownumSpan.parentElement?.querySelector('.ft-link')) return;
    const a = document.createElement('a'); a.className='ft-link'; a.href = '#ft-' + CSS.escape(label);
    const sup = document.createElement('sup'); sup.textContent='T'; a.appendChild(sup);
    const tip = document.createElement('div'); tip.className='ft-tooltip-content'; tip.style.display='none'; tip.textContent = text;
    rownumSpan.parentElement?.appendChild(a);
    rownumSpan.parentElement?.appendChild(tip);
  });
  // Build section before Notes
  const wrap = document.createElement('div'); wrap.className='chart-freetrans';
  const h = document.createElement('h3'); h.textContent='Free translations'; wrap.appendChild(h);
  // Render FT items in row order by scanning rows and using GUID lookup
  const rowOrder = Array.from(tbl.querySelectorAll('tbody tr')).filter(r=> !r.classList.contains('title1') && !r.classList.contains('title2') && !r.classList.contains('ft-inline'));
  rowOrder.forEach(tr=>{
    const label = computeRowLabelFromRow(tr); const text = items[label]; if(!text) return;
    const item = document.createElement('div'); item.className='ft-item'; item.id = 'ft-' + label;
    const lab = document.createElement('div'); lab.className='ft-label';
    const back = document.createElement('a'); back.href = '#row-' + label + '-ftsrc'; back.textContent = label; // back to row number
    lab.appendChild(back);
    const body = document.createElement('div'); body.textContent = text;
    item.appendChild(lab); item.appendChild(body); wrap.appendChild(item);
  });
  // Insert wrap after table, before .chart-endnotes if present
  const areaRoot = byId('renderArea');
  const tableWrap = areaRoot.querySelector('table.chartshell')?.closest('.chartshell-wrapper') || areaRoot.querySelector('table.chartshell');
  const notes = areaRoot.querySelector(':scope > .chart-endnotes');
  if(notes) areaRoot.insertBefore(wrap, notes); else if(tableWrap){ if(tableWrap.nextSibling) areaRoot.insertBefore(wrap, tableWrap.nextSibling); else areaRoot.appendChild(wrap); }
  // rewire tooltip handlers for newly added links
  if(window.wireNoteTooltips){ try{ window.wireNoteTooltips(); }catch(_){} }
}
function applyFT_InlineMode(area, tbl, items){
  const total = computeTotalColumns(tbl);
  // Apply CSS variables for inline styling from prefs
  try{
    const p = loadFTPrefs(); const st = p.style || {};
    const root = tbl.closest('.viewer') || document.documentElement;
    if(st.fontSize) root.style.setProperty('--ft-inline-font-size', st.fontSize); else root.style.removeProperty('--ft-inline-font-size');
    if(st.color) root.style.setProperty('--ft-inline-color', st.color); else root.style.removeProperty('--ft-inline-color');
    if(st.bg) root.style.setProperty('--ft-inline-bg', st.bg); else root.style.removeProperty('--ft-inline-bg');
  }catch(_){ /* ignore */ }
  Array.from(tbl.querySelectorAll('tbody tr')).forEach(tr=>{
    if(tr.classList.contains('title1') || tr.classList.contains('title2') || tr.classList.contains('ft-inline')) return;
    const label = computeRowLabelFromRow(tr); const text = items[label]; if(!text) return;
    const row = document.createElement('tr'); row.className='ft-inline';
    const td = document.createElement('td'); td.colSpan = total; const lab = document.createElement('span'); lab.className='ft-label'; lab.textContent = 'Free translation:'; td.appendChild(lab); const span = document.createElement('span'); span.textContent=' ' + text; td.appendChild(span); row.appendChild(td);
    if(tr.nextSibling) tr.parentElement.insertBefore(row, tr.nextSibling); else tr.parentElement.appendChild(row);
  });
}
function applyFreeTranslationsToArea(area){
  area = area || byId('renderArea'); if(!area) return;
  const tbl = area.querySelector('table.chartshell'); if(!tbl) return;
  clearExistingFTArtifacts(area);
  const prefs = loadFTPrefs(); const mode = prefs.mode || 'tooltip'; const items = prefs.items || {};
  if(mode === 'inline') applyFT_InlineMode(area, tbl, items);
  else applyFT_TooltipMode(area, tbl, items);
}

/* ===== Notes options controls ===== */
const NOTES_PREFS_KEY = 'flex_textchart_notes_prefs_v1';
function loadNotesPrefs(){ const d = loadJSON(NOTES_PREFS_KEY) || {}; return { mode: d.mode || 'inline', width: d.width || '' }; }
function saveNotesPrefs(p){ saveJSON(NOTES_PREFS_KEY, p); }
function showNotesPanel(show){ const p = byId('notesPanel'); if(p) p.style.display = show ? 'block' : 'none'; }
function initNotesControls(){
  const modeSel = byId('notesMode'); const widthIn = byId('notesWidth'); const resetBtn = byId('notesReset');
  if(!modeSel || !widthIn) return;
  const prefs = loadNotesPrefs();
  modeSel.value = prefs.mode || 'inline';
  widthIn.value = prefs.width || '';
  const onChange = ()=>{
    const p = { mode: modeSel.value, width: widthIn.value.trim() };
    saveNotesPrefs(p);
    // Re-render the current document if a chart is visible by triggering transform
    const xmlText = byId('xmlInput').value.trim();
    if(xmlText){
      try{
        const dom = new DOMParser().parseFromString(xmlText, 'application/xml');
        if(!dom.querySelector('parsererror')) renderDocument(dom);
      }catch(_){/* ignore */}
    }
  };
  modeSel.addEventListener('change', onChange);
  widthIn.addEventListener('change', onChange);
  byId('notesReset')?.addEventListener('click', ()=>{ modeSel.value='inline'; widthIn.value=''; onChange(); });
}

/* ===== Salience Bands (row color coding) ===== */
function showSaliencePanel(show){ const p = byId('saliencePanel'); if(p) p.style.display = show ? 'block' : 'none'; }
function loadSaliencePrefs(){
  const d = loadJSON(SALIENCE_PREFS_KEY) || {};
  return {
    enabled: d.enabled !== false,
    showLegend: d.showLegend !== false,
    showColumn: !!d.showColumn,
    cellOnly: !!d.cellOnly,
    opacity: (typeof d.opacity === 'number') ? d.opacity : 1,
    tree: Array.isArray(d.tree) ? d.tree : [],
    // assignments: map of rowGuid -> bandId; support legacy label keys and migrate lazily
    assignments: d.assignments || {}
  };
}
function saveSaliencePrefs(p){
  const out = {
    enabled: (typeof p.enabled === 'boolean') ? p.enabled : true,
    showLegend: (typeof p.showLegend === 'boolean') ? p.showLegend : true,
    showColumn: !!p.showColumn,
    cellOnly: !!p.cellOnly,
    opacity: (typeof p.opacity === 'number') ? p.opacity : 1,
    tree: Array.isArray(p.tree)?p.tree:[],
    // Keep assignments as-is; explicit delete flows (e.g., removeNode) will clean up invalid IDs
    assignments: p.assignments || {}
  };
  // Inherit colors: fill missing child colors from nearest ancestor on save
  (function inherit(list, parentColor){
    (list||[]).forEach(n=>{
      if(!n.color && parentColor) n.color = parentColor;
      inherit(n.children||[], n.color || parentColor);
    });
  })(out.tree, null);
  saveJSON(SALIENCE_PREFS_KEY, out);
}
function newSalNode(label){ return { id: 'sal_'+Date.now().toString(36)+'_'+Math.floor(Math.random()*1000), label: label||'Band', color: '#fffad1', children: [] }; }
function findNode(rootList, id){
  const stack = rootList.map((n,idx)=>({ node:n, parent:null, index:idx, list:rootList }));
  while(stack.length){ const cur = stack.pop(); if(cur.node.id===id) return cur; (cur.node.children||[]).forEach((c,i)=> stack.push({ node:c, parent:cur.node, index:i, list:cur.node.children })); }
  return null;
}
function computeSalienceNumbers(tree){
  const map = {};
  (function walk(list, prefix){
    (list||[]).forEach((n, i)=>{
      const num = prefix ? (prefix + '.' + (i+1)) : String(i+1);
      map[n.id] = num;
      walk(n.children||[], num);
    });
  })(tree||[], '');
  return map;
}
function initSalienceControls(){
  const listHost = byId('salienceList'); if(!listHost) return;
  const addRootBtn = byId('salAddRoot');
  const clearAssignBtn = byId('salClearAssignments');
  const enabledCb = byId('salienceEnabled');
  const legendCb = byId('salienceShowLegend');
  const colCb = byId('salienceShowColumn');
  const cellOnlyCb = byId('salienceCellOnly');
  const opacityRange = byId('salienceOpacity');
  let prefs = loadSaliencePrefs();
  if(enabledCb){ enabledCb.checked = !!prefs.enabled; enabledCb.addEventListener('change', ()=>{ prefs.enabled = !!enabledCb.checked; persist(); }); }
  if(legendCb){ legendCb.checked = !!prefs.showLegend; legendCb.addEventListener('change', ()=>{ prefs.showLegend = !!legendCb.checked; persist(); }); }
  if(colCb){ colCb.checked = !!prefs.showColumn; colCb.addEventListener('change', ()=>{ prefs.showColumn = !!colCb.checked; persist(); }); }
  if(cellOnlyCb){ cellOnlyCb.checked = !!prefs.cellOnly; cellOnlyCb.addEventListener('change', ()=>{ prefs.cellOnly = !!cellOnlyCb.checked; persist(); }); }
  if(opacityRange){ opacityRange.value = String((typeof prefs.opacity==='number'?prefs.opacity:1)); opacityRange.addEventListener('input', ()=>{ prefs.opacity = Number(opacityRange.value); persist(); }); }
  function persist(options){
    const mergeAssignments = !options || options.mergeAssignments !== false;
    if(mergeAssignments){
      try{
        const latest = loadSaliencePrefs();
        // Union storage and in-memory assignments to avoid clobbering recent row picks
        const curA = prefs.assignments || {};
        const latA = (latest && latest.assignments) || {};
        prefs.assignments = Object.assign({}, latA, curA);
        // Ensure tree is at least defined to avoid accidental pruning when an empty object is saved from elsewhere
        if(!Array.isArray(prefs.tree)){
          if(Array.isArray(latest.tree)) prefs.tree = latest.tree;
          else prefs.tree = [];
        }
      }catch(_){ /* ignore */ }
    }
    saveSaliencePrefs(prefs);
    refreshSalienceVisuals(byId('renderArea'));
  }
  function removeNode(id){
    function rec(list){
      const idx = list.findIndex(x=> x.id===id);
      if(idx!==-1){ list.splice(idx,1); return true; }
      return list.some(n=> rec(n.children||[]));
    }
    rec(prefs.tree);
    // Remove assignments to this node and all descendants
    const toDelete = new Set(); (function collect(id){ const hit = findNode(prefs.tree, id); if(hit){ toDelete.add(hit.node.id); (hit.node.children||[]).forEach(c=> collect(c.id)); } })(id);
    Object.keys(prefs.assignments).forEach(row=>{ if(toDelete.has(prefs.assignments[row])) delete prefs.assignments[row]; });
  }
  function moveUp(id){ const loc = findNode(prefs.tree, id); if(!loc) return; const arr = loc.list; const i = loc.index; if(i>0){ const t=arr[i-1]; arr[i-1]=arr[i]; arr[i]=t; persist(); render(); } }
  function moveDown(id){ const loc = findNode(prefs.tree, id); if(!loc) return; const arr = loc.list; const i = loc.index; if(i < arr.length-1){ const t=arr[i+1]; arr[i+1]=arr[i]; arr[i]=t; persist(); render(); } }
  function promote(id){
    const loc = findNode(prefs.tree, id); if(!loc || !loc.parent) return; // already root
    const parentLoc = findNode(prefs.tree, loc.parent.id);
    const grandList = parentLoc ? parentLoc.list : prefs.tree;
    // Remove from current list
    loc.list.splice(loc.index,1);
    // Insert after parent
    const parentIndex = grandList.indexOf(loc.parent);
    grandList.splice(parentIndex+1, 0, loc.node);
    persist(); render();
  }
  function demote(id){
    const loc = findNode(prefs.tree, id); if(!loc) return; const arr = loc.list; const i = loc.index; if(i<=0) return; // need a previous sibling
    const prev = arr[i-1]; prev.children = Array.isArray(prev.children) ? prev.children : [];
    // Remove from current and push into prev.children
    arr.splice(i,1); prev.children.push(loc.node);
    persist(); render();
  }
  function addChild(id){ const loc = findNode(prefs.tree, id); if(!loc) return; loc.node.children = Array.isArray(loc.node.children) ? loc.node.children : []; loc.node.children.push(newSalNode('Child')); persist(); render(); }
  function render(){
    const nums = computeSalienceNumbers(prefs.tree);
    listHost.innerHTML='';
    function renderList(list, level){
      const ul = document.createElement('ul'); ul.className='salience-tree'; if(level>0) ul.style.marginLeft = (level*16) + 'px';
      (list||[]).forEach((n)=>{
        const li = document.createElement('li'); li.className='sal-item';
    const num = document.createElement('span'); num.className='sal-num'; num.textContent = nums[n.id] || '';
  const color = document.createElement('input'); color.type='color'; color.value = n.color || (level>0 ? (findParentColor(prefs.tree, n.id)||'#fffad1') : '#fffad1'); color.title='Row background'; color.addEventListener('input', ()=>{ n.color=color.value; persist(); /* ensure all visuals sync immediately */ refreshSalienceVisuals(byId('renderArea')); });
        const colorSw = document.createElement('span'); colorSw.className='sal-color'; colorSw.style.background = color.value; color.addEventListener('input', ()=>{ colorSw.style.background=color.value; });
  const label = document.createElement('input'); label.type='text'; label.value = n.label || ''; label.placeholder='Label (e.g., secondary event line)'; label.addEventListener('input', ()=>{ n.label = label.value; persist(); refreshSalienceVisuals(byId('renderArea')); });
        const up = document.createElement('button'); up.className='sal-btn'; up.title='Move up'; up.textContent='↑'; up.addEventListener('click', ()=> moveUp(n.id));
        const down = document.createElement('button'); down.className='sal-btn'; down.title='Move down'; down.textContent='↓'; down.addEventListener('click', ()=> moveDown(n.id));
        const prom = document.createElement('button'); prom.className='sal-btn'; prom.title='Promote (outdent)'; prom.textContent='←'; prom.addEventListener('click', ()=> promote(n.id));
        const demo = document.createElement('button'); demo.className='sal-btn'; demo.title='Demote (indent)'; demo.textContent='→'; demo.addEventListener('click', ()=> demote(n.id));
        const add = document.createElement('button'); add.className='sal-btn'; add.title='Add sub-band'; add.textContent='＋'; add.addEventListener('click', ()=> addChild(n.id));
  const del = document.createElement('button'); del.className='sal-btn'; del.title='Delete band'; del.textContent='🗑'; del.addEventListener('click', ()=>{ if(confirm('Delete this band and any sub-bands?')){ removeNode(n.id); persist({ mergeAssignments: false }); render(); } });
        li.appendChild(num); li.appendChild(colorSw); li.appendChild(color); li.appendChild(label); li.appendChild(up); li.appendChild(down); li.appendChild(prom); li.appendChild(demo); li.appendChild(add); li.appendChild(del);
        ul.appendChild(li);
        if(n.children && n.children.length){ ul.appendChild(renderList(n.children, level+1)); }
      });
      return ul;
    }
    listHost.appendChild(renderList(prefs.tree, 0));
  }
  if(addRootBtn){ addRootBtn.onclick = ()=>{ prefs.tree.push(newSalNode('Band')); persist(); render(); }; }
  if(clearAssignBtn){ clearAssignBtn.onclick = ()=>{ if(confirm('Clear all row salience assignments?')){ prefs.assignments = {}; persist({ mergeAssignments: false }); render(); } }; }
  // First render
  render();
}
function findParentColor(tree, id){
  const loc = findNode(tree, id); if(!loc || !loc.parent) return null; return loc.parent.color || findParentColor(tree, loc.parent.id);
}
function buildSalienceOptions(){
  const prefs = loadSaliencePrefs(); const nums = computeSalienceNumbers(prefs.tree);
  const opts = [];
  (function walk(list){ (list||[]).forEach(n=>{ opts.push({ id:n.id, number: nums[n.id]||'', label: n.label||'', color: n.color||'#fffad1' }); walk(n.children||[]); }); })(prefs.tree||[]);
  return opts;
}
function showSaliencePicker(title, currentId){
  return new Promise(resolve=>{
    const overlay = document.createElement('div'); overlay.className='modal-overlay';
    const modal = document.createElement('div'); modal.className='modal'; overlay.appendChild(modal);
    const h = document.createElement('h3'); h.textContent = title || 'Select salience band'; modal.appendChild(h);
    const sel = document.createElement('select'); sel.style.width='100%'; sel.style.padding='8px'; sel.style.border='1px solid #e5e5e5'; sel.style.borderRadius='6px';
    const none = document.createElement('option'); none.value=''; none.textContent='(None)'; sel.appendChild(none);
    const opts = buildSalienceOptions();
    opts.forEach(o=>{ const opt = document.createElement('option'); opt.value=o.id; opt.textContent = `${o.number} — ${o.label || '(unnamed)'}`; if(currentId===o.id) opt.selected=true; sel.appendChild(opt); });
    modal.appendChild(sel);
    const actions = document.createElement('div'); actions.className='modal-actions'; modal.appendChild(actions);
    const cancel = document.createElement('button'); cancel.className='secondary'; cancel.textContent='Cancel';
    const save = document.createElement('button'); save.textContent='Save';
    actions.appendChild(cancel); actions.appendChild(save);
    function done(val){ document.body.removeChild(overlay); resolve(val); }
    cancel.addEventListener('click', ()=> done(null));
    save.addEventListener('click', ()=> done(sel.value || ''));
    overlay.addEventListener('click', (e)=>{ if(e.target === overlay) done(null); });
    document.body.appendChild(overlay);
  });
}
function wireSalienceButtons(area){
  const tbl = area?.querySelector('table.chartshell'); if(!tbl) return;
  // Remove any existing buttons first
  tbl.querySelectorAll('.add-band-btn').forEach(b=> b.remove());
  const prefs = loadSaliencePrefs();
  Array.from(tbl.querySelectorAll('tbody tr')).forEach(tr=>{
    if(tr.classList.contains('title1') || tr.classList.contains('title2') || tr.classList.contains('ft-inline')) return;
    const firstCell = tr.querySelector('td'); if(!firstCell) return;
    const rownumSpan = firstCell.querySelector('.interlinear .pair .w.rownum'); if(!rownumSpan) return;
    const rowLabel = computeRowLabelFromRow(tr);
    const btn = document.createElement('button'); btn.type='button'; btn.className='add-band-btn';
    function setBtnText(){
      const a = (loadSaliencePrefs().assignments||{});
      const id = a[rowLabel];
      if(!id){ btn.textContent = 'Salience band…'; btn.title='Assign a salience band to this row'; }
      else {
        const opts = buildSalienceOptions(); const x = opts.find(o=>o.id===id);
        const num = x ? x.number : ''; const lab = x ? x.label : '';
        btn.textContent = num ? `Band ${num}` : 'Band'; btn.title = lab ? lab : 'Assigned band';
      }
    }
    setBtnText();
    btn.addEventListener('click', async ()=>{
  const prefs = loadSaliencePrefs(); const a = prefs.assignments||{}; const current = a[rowLabel] ?? '';
      const hasBands = (buildSalienceOptions().length > 0);
      if(!hasBands){
        if(confirm('No salience bands defined yet. Open Salience Bands panel to add one?')){
          // Expand the panel
          const panel = byId('saliencePanel'); const header = byId('salienceHeader');
          if(panel && header && panel.getAttribute('data-collapsed')==='1'){ header.click(); }
        }
        return;
      }
      const sel = await showSaliencePicker('Salience band — row '+rowLabel, current);
      if(sel === null) return; // cancelled
  const p = loadSaliencePrefs(); p.assignments = p.assignments || {};
  if(sel){ p.assignments[rowLabel] = sel; }
  else { delete p.assignments[rowLabel]; }
      saveSaliencePrefs(p);
      setBtnText();
      refreshSalienceVisuals(area);
    });
    rownumSpan.parentElement?.appendChild(btn);
  });
}
function updateSalienceButtons(area){
  const tbl = area?.querySelector('table.chartshell'); if(!tbl) return;
  Array.from(tbl.querySelectorAll('tbody tr')).forEach(tr=>{
    if(tr.classList.contains('title1') || tr.classList.contains('title2') || tr.classList.contains('ft-inline')) return;
    const firstCell = tr.querySelector('td'); if(!firstCell) return;
    const rownumSpan = firstCell.querySelector('.interlinear .pair .w.rownum'); if(!rownumSpan) return;
    const rowLabel = computeRowLabelFromRow(tr);
    const btn = rownumSpan.parentElement?.querySelector('.add-band-btn'); if(!btn) return;
    const a = (loadSaliencePrefs().assignments||{}); const id = a[rowLabel];
    if(!id){ btn.textContent='Salience band…'; btn.title='Assign a salience band to this row'; }
    else { const opts = buildSalienceOptions(); const x = opts.find(o=>o.id===id); const num = x?x.number:''; const lab=x?x.label:''; btn.textContent = num?`Band ${num}`:'Band'; btn.title = lab||'Assigned band'; }
  });
}
function applySalienceBandsToArea(area){
  area = area || byId('renderArea'); if(!area) return;
  const tbl = area.querySelector('table.chartshell'); if(!tbl) return;
  // Clear previous coloring
  Array.from(tbl.querySelectorAll('tbody tr')).forEach(tr=>{
    if(tr.classList.contains('title1') || tr.classList.contains('title2') || tr.classList.contains('ft-inline')) return;
    Array.from(tr.children).forEach(td=>{ if(td.dataset.salApplied==='1'){ td.style.backgroundColor=''; delete td.dataset.salApplied; } });
  });
  const prefs = loadSaliencePrefs();
  if(!prefs.enabled){ return; }
  const idToColor = {}; (function walk(list){ (list||[]).forEach(n=>{ idToColor[n.id]=n.color||'#fffad1'; walk(n.children||[]); }); })(prefs.tree||[]);
  // Apply
  // Apply assignments by scanning rows to resolve GUIDs on the fly
  const rows = Array.from(tbl.querySelectorAll('tbody tr')).filter(r=> !r.classList.contains('title1') && !r.classList.contains('title2') && !r.classList.contains('ft-inline'));
  rows.forEach(tr=>{
    const label = computeRowLabelFromRow(tr);
    const bandId = prefs.assignments[label];
    const color = bandId ? idToColor[bandId] : null; if(!color) return;
    if(!tr) return;
    const bg = alphaColor(color, prefs.opacity);
    if(prefs.cellOnly){
      const cell = tr.querySelector(':scope > td[data-sal-col="1"]') || tr.firstElementChild;
      if(cell){ cell.style.backgroundColor = bg; cell.dataset.salApplied='1'; }
    } else {
      Array.from(tr.children).forEach(td=>{ td.style.backgroundColor = bg; td.dataset.salApplied='1'; });
    }
  });
  // Keep column cells in sync if present
  updateSalienceColumnCells(tbl);
}
</script>
</body>
</html>
